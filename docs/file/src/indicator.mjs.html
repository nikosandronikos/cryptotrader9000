<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <base data-ice="baseUrl" href="../../">
  <title data-ice="title">src/indicator.mjs | cryptotrader9000</title>
  <link type="text/css" rel="stylesheet" href="css/style.css">
  <link type="text/css" rel="stylesheet" href="css/prettify-tomorrow.css">
  <script src="script/prettify/prettify.js"></script>
  <script src="script/manual.js"></script>
<meta name="description" content="A very basic rule based trading bot for Binance. For fun, not profit."><meta property="twitter:card" content="summary"><meta property="twitter:title" content="cryptotrader9000"><meta property="twitter:description" content="A very basic rule based trading bot for Binance. For fun, not profit."></head>
<body class="layout-container" data-ice="rootContainer">

<header>
  <a href="./">Home</a>
  
  <a href="identifiers.html">Reference</a>
  <a href="source.html">Source</a>
  
  <div class="search-box">
  <span>
    <img src="./image/search.png">
    <span class="search-input-edge"></span><input class="search-input"><span class="search-input-edge"></span>
  </span>
    <ul class="search-result"></ul>
  </div>
<a style="position:relative; top:3px;" href="https://github.com/nikosandronikos/cryptotrader9000"><img width="20px" src="./image/github.png"></a></header>

<nav class="navigation" data-ice="nav"><div>
  <ul>
    
  <li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/binance.mjs~BinanceAccess.html">BinanceAccess</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/binancestream.mjs~BinanceStream.html">BinanceStream</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/binancestream.mjs~BinanceStreamDepth.html">BinanceStreamDepth</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/binancestream.mjs~BinanceStreamKlines.html">BinanceStreamKlines</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/binancestream.mjs~BinanceStreamTicker.html">BinanceStreamTicker</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/coin.mjs~Coin.html">Coin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/coin.mjs~CoinPair.html">CoinPair</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/indicator.mjs~EMAIndicator.html">EMAIndicator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/indicator.mjs~Indicator.html">Indicator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/indicator.mjs~MultiEMAIndicator.html">MultiEMAIndicator</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/log.mjs~Log.html">Log</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/telegram.mjs~TelegramBot.html">TelegramBot</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-class">C</span><span data-ice="name"><span><a href="class/src/timeseries.mjs~TimeSeriesData.html">TimeSeriesData</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-ObservableMixin">ObservableMixin</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-chartIntervalToMs">chartIntervalToMs</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-findCross">findCross</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-function">F</span><span data-ice="name"><span><a href="function/index.html#static-function-intervalToMs">intervalToMs</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-BinanceCommands">BinanceCommands</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-variable">V</span><span data-ice="name"><span><a href="variable/index.html#static-variable-log">log</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-Any">Any</a></span></span></li>
<li data-ice="doc"><span data-ice="kind" class="kind-typedef">T</span><span data-ice="name"><span><a href="typedef/index.html#static-typedef-ComparisonType">ComparisonType</a></span></span></li>
</ul>
</div>
</nav>

<div class="content" data-ice="content"><h1 data-ice="title">src/indicator.mjs</h1>
<pre class="source-code line-number raw-source-code"><code class="prettyprint linenums" data-ice="content">import Big from &apos;big.js&apos;;
import {ObservableMixin} from &apos;./observable&apos;;
import {BinanceStreamKlines} from &apos;./binancestream.mjs&apos;;
import {TimeSeriesData} from &apos;./timeseries&apos;;
import {findCross} from &apos;./utils&apos;;
import {log} from &apos;./log&apos;;

Big.DP = 8;

// Will update based on ticker.
// But will also need historical data.
export class Indicator extends ObservableMixin(Object) {
    constructor(binance, coinPair) {
        super();
        this.binance = binance;
        this.coinPair = coinPair;
    }

    getCurrent() {
        throw &apos;Implement in sub-class.&apos;;
    }
}

export class EMAIndicator extends Indicator {
    constructor(binance, coinPair, nPeriods, interval) {
        super(binance, coinPair);
        this.nPeriods = nPeriods;
        this.interval = interval;

        this.source = null;
        this.data = new TimeSeriesData(interval);
    }

    async init() {
        // Set up stream
        this.stream = await BinanceStreamKlines.create(
            this.binance,
            this.coinPair.symbol,
            this.interval,
            &apos;k.c&apos;   // close price
        );
        // Get the history we will need to compute EMA.
        // getHistory returns a TimeSeriesData which we will use from now on.
        // FIXME: Should get more history and pre-compute EMA for a while
        // because it takes a while to converge to the correct value.
        this.source = await this.stream.getHistory(1);
        // Feed stream data in the TimeSeriesData store
        this.stream.addObserver(&apos;newData&apos;, this.source.addData, this.source);

        // FIXME: Not sure what events would be best coming from the
        //        TimeSeries class yet.
        //const showCalc = () =&gt; log.debug(
        //    `${this.coinPair.symbol} ${this.interval}`
        //    +` EMA${this.nPeriods} = ${this._calculate()}`
        //);

        this.source.addObserver(&apos;extended&apos;, this._calculate, this);
        this.source.addObserver(&apos;replaceRecent&apos;, this._calculate, this);

        //showCalc();
    }

    static async createAndInit(binance, coinPair, nPeriods, interval) {
        log.info(`Creating EMAIndicator for ${coinPair.symbol} (${nPeriods}) ${interval}`);
        const ema = new EMAIndicator(binance, coinPair, nPeriods, interval);
        await ema.init();
        return ema;
    }

    _calculate() {
        const time = this.binance.getTimestamp();
        const current = this.source.getRecent(1, time)[0];
        // Either last EMA if available or last close price
        let last = NaN;
        last = this.data.getRecent(2, time)[0];
        if (last === undefined) last = current;

        // Weighting for most recent close price.
        const multiplier = Big(2).div(this.nPeriods + 1);

        const ema = current.times(multiplier).add(last.times(Big(1).sub(multiplier))).round(8);
        this.data.addData(time, ema);
        this.notifyObservers(&apos;update&apos;, time, ema);
        return ema;
    }
}

export class MultiEMAIndicator extends Indicator {
    constructor(binance, coinPair, interval, lengths) {
        super(binance, coinPair);
        this.lengths = lengths;
        this.lengths.sort((a,b) =&gt; b - a);
        this.interval = interval;
        this.emas = [];
        this.orderedEmas = null;
        this.data = new TimeSeriesData(interval);
        this.currentTime = 0;
        this.nUpdates = 0;
        this.nFullUpdates = 0;
    }

    async init() {
        for (const length of this.lengths) {
            const ema = await EMAIndicator.createAndInit(
                this.binance,
                this.coinPair,
                length,
                this.interval
            );
            this.emas.push(ema);
        }
        for (const ema of this.emas) {
            // FIXME: Should this just be closed prices?
            // eslint-disable-next-line no-unused-vars
            ema.addObserver(&apos;update&apos;, (time, ema) =&gt; {
                if (time &gt; this.currentTime) {
                    this.currentTime = time;
                    this.nUpdates = 0;
                }
                this.nUpdates ++;
                if (this.nUpdates == this.lengths.length) {
                    log.debug(`MultiEMA: Got all ${this.nUpdates} for ${this.currentTime}`);
                    this._update(time);
                }
            });
        }
    }

    _update(time) {
        const slow = this.emas[0].data.getRecent(1, time)[0];
        const fast = this.emas[this.emas.length - 1].data.getRecent(1, time)[0];
        const newOrder = [];

        this.nFullUpdates ++;

        for (const ema of this.emas) {
            // @TODO getRecent, given the same time should always return the
            // same price. Need to add a test for this. Exception is if
            // the period isn&apos;t closed.
            // If not doing closed prices. We may want to freeze the price here
            // and store a wrapper rather than the actual ema instance.
            newOrder.push(ema);
            //{
            //    ind:    ema,
            //    length: ema.nPeriods,
            //    price:  ema.data.getRecent(1, time)[0]
            //});
        }
        newOrder.sort((a,b) =&gt; {
            const aPrice = a.data.getRecent(1,time)[0];
            const bPrice = b.data.getRecent(1,time)[0];
            const priceCmp = aPrice.cmp(bPrice);
            //log.debug(priceCmp, b.nPeriods, a.nPeriods);
            return priceCmp == 0 ? a.nPeriods - b.nPeriods : priceCmp;
        });

        if (this.orderedEmas === null) {
            this.orderedEmas = newOrder;
            return;
        }

        if (this.nFullUpdates &lt; 21) {
            log.debug(this.nFullUpdates);
            return;
        }
        this.notifyObservers(&apos;update&apos;);

        for (let i = 0; i &lt; newOrder.length; i++) {
            log.debug(
                &apos;  &apos;, this.orderedEmas[i].nPeriods, newOrder[i].nPeriods,
                &apos;:&apos;, newOrder[i].data.getRecent(1, time)[0].toString()
            );
        }

        const cross = findCross(
                this.orderedEmas, newOrder, fast.nPeriods, slow.nPeriods, (a) =&gt; a.nPeriods
            );
        this.orderedEmas = newOrder;

        log.debug(cross);

        if (cross.crossed === []) return;

        if (cross.fastSlowCross) {
            // FIXME: Should we provide prices of emas?
            this.notifyObservers(&apos;fastSlowCross&apos;, cross.crossed, time);
            return;
        }

        this.notifyObservers(&apos;cross&apos;, cross.crossed, time);
    }

    static async createAndInit(binance, coinPair, interval, lengths) {
        log.info(`Creating MultiEMAIndicator for ${coinPair.symbol} (${interval}) ${lengths}`);
        const ind = new MultiEMAIndicator(binance, coinPair, interval, lengths);
        await ind.init();
        return ind;
    }
}
</code></pre>

</div>

<footer class="footer">
  Generated by <a href="https://esdoc.org">ESDoc<span data-ice="esdocVersion">(1.1.0)</span><img src="./image/esdoc-logo-mini-black.png"></a>
</footer>

<script src="script/search_index.js"></script>
<script src="script/search.js"></script>
<script src="script/pretty-print.js"></script>
<script src="script/inherited-summary.js"></script>
<script src="script/test-summary.js"></script>
<script src="script/inner-link.js"></script>
<script src="script/patch-for-local.js"></script>
</body>
</html>
