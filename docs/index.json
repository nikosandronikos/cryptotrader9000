[
  {
    "__docId__": 0,
    "kind": "file",
    "name": "src/account.mjs",
    "content": "import {BinanceCommands} from './binance.mjs';\nimport {Coin} from './coin.mjs';\nimport {log} from './log';\n\n/**\n * @access Public\n */\nexport class Account {\n    constructor(binance, name, key, secret) {\n        // BinanceAccess instance.\n        this.binance = binance;\n        // A human readable name used to identify this account.\n        this.name = name;\n        // The accounts Binance API key.\n        this.key = key;\n        // The accounts Binance API key secret.\n        this.secret = secret;\n        // A map of coin name => Coin object pairs, initially populated\n        // with all coins with a non zero balance.\n        this.hodl = new Map();\n    }\n\n    async syncBalances() {\n        const info = await this.binance.apiCommand(\n            BinanceCommands.accountInfo,\n            {timestamp: this.binance.getTimestamp()},\n            this.name\n        );\n\n        for (const coinInfo of info.balances) {\n            const free = parseFloat(coinInfo.free);\n            const locked = parseFloat(coinInfo.locked);\n\n            if (free === 0.0 && locked === 0.0) continue;\n            log.debug(coinInfo.asset, free, locked);\n            let coin = null;\n            if (!this.hodl.has(coinInfo.asset)) {\n                coin = new Coin(coinInfo.asset, free, locked);\n                this.hodl.set(coinInfo.asset, coin);\n            } else {\n                // If an entry already exists for this coin, the\n                // balances are over-written.\n                coin = this.hodl.get(coinInfo.asset);\n                coin.free = free;\n                coin.locked = locked;\n            }\n        }\n    }\n}\n",
    "static": true,
    "longname": "/home/nikos/Documents/code/cryptotrader9000/src/account.mjs",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 1,
    "kind": "class",
    "name": "Account",
    "memberof": "src/account.mjs",
    "static": true,
    "longname": "src/account.mjs~Account",
    "access": "Public",
    "export": true,
    "importPath": "cryptotrader9000/src/account.mjs",
    "importStyle": "{Account}",
    "description": "",
    "lineNumber": 8,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 2,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/account.mjs~Account",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/account.mjs~Account#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true
  },
  {
    "__docId__": 3,
    "kind": "member",
    "name": "binance",
    "memberof": "src/account.mjs~Account",
    "static": false,
    "longname": "src/account.mjs~Account#binance",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 4,
    "kind": "member",
    "name": "name",
    "memberof": "src/account.mjs~Account",
    "static": false,
    "longname": "src/account.mjs~Account#name",
    "access": "public",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 5,
    "kind": "member",
    "name": "key",
    "memberof": "src/account.mjs~Account",
    "static": false,
    "longname": "src/account.mjs~Account#key",
    "access": "public",
    "description": null,
    "lineNumber": 15,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 6,
    "kind": "member",
    "name": "secret",
    "memberof": "src/account.mjs~Account",
    "static": false,
    "longname": "src/account.mjs~Account#secret",
    "access": "public",
    "description": null,
    "lineNumber": 17,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 7,
    "kind": "member",
    "name": "hodl",
    "memberof": "src/account.mjs~Account",
    "static": false,
    "longname": "src/account.mjs~Account#hodl",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 8,
    "kind": "method",
    "name": "syncBalances",
    "memberof": "src/account.mjs~Account",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/account.mjs~Account#syncBalances",
    "access": "public",
    "description": null,
    "lineNumber": 23,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 9,
    "kind": "file",
    "name": "src/binance.mjs",
    "content": "import axios from 'axios';\nimport crypto from 'crypto';\nimport querystring from 'querystring';\n\nimport {intervalToMs} from './utils.mjs';\nimport {CoinPair} from './coin.mjs';\nimport {Account} from './account.mjs';\nimport {StreamManager} from './binancestream.mjs';\nimport {log} from './log.mjs';\n\n/**\n * Command descriptions that are passed to {@link BinanceAccess.apiCommand}.\n * @access public\n */\nexport const BinanceCommands = {\n    time: {\n        name: 'exchangeTime',\n        url: 'api/v1/time',\n        weight: 1,\n        limitType: 'REQUESTS'\n    },\n    info: {\n        name: 'exchangeInfo',\n        url: 'api/v1/exchangeInfo',\n        weight: 1,\n        limitType: 'REQUESTS'\n    },\n    klines: {\n        name: 'klines',\n        url: 'api/v1/klines',\n        weight: 1,\n        limitType: 'REQUESTS',\n        reqParams: ['symbol', 'interval']\n    },\n    openOrdersForSymbol: {\n        name: 'openOrdersForSymbol',\n        url:       '/api/v3/openOrders',\n        weight:    1,\n        limitType: 'REQUESTS',\n        reqAuth:   true,\n        reqParams: ['symbol', 'timestamp']\n    },\n    accountInfo: {\n        name:   'accountInfo',\n        url:    '/api/v3/account',\n        weight: 5,\n        limitType:  'REQUESTS',\n        reqAuth:    true,\n        reqParams:  ['timestamp']\n    },\n    available: {\n        name: 'apiAvailable',\n        url: 'api/v1/ping',\n        weight: 1\n    }\n};\n\n/**\n * @access package\n */\nclass Limits {\n    constructor() {\n        this._limits = new Map();\n    }\n\n    setLimit(type, max, interval) {\n        if (!this._limits.has(type)) {\n            this._limits.set(type, []);\n        }\n\n        const intervalMs = intervalToMs(interval);\n        const limits = this._limits.get(type);\n\n        // Overwrite any existing limit of this interval\n        for (const limit of limits) {\n            if (limit.interval == intervalMs) {\n                limit.max = max;\n                return;\n            }\n        }\n\n        limits.push({\n            max: max,\n            remain: max,\n            interval: intervalMs,\n            start: Date.now()\n        });\n    }\n\n    // Tests against a limit and returns false if the limit is exceeded.\n    // If the limit is not exceed, true is returned and an operation is\n    // recorded against the limit.\n    testAndExecute(type) {\n        const limits = this._limits.get(type);\n        if (limits === undefined) {\n            log.info(this._limits);\n            throw `${type} is not a valid limit type`;\n        }\n\n        for (const limit of limits) {\n            if (limit.remain < 1) return false;\n            limit.remain --;\n        }\n\n        return true;\n    }\n\n    update(time) {\n        for (const limitType of this._limits) {\n            for (const limit of limitType) {\n                if (time - limit.start > limit.interval) {\n                    limit.start = time;\n                    limit.remain = limit.max;\n                }\n            }\n        }\n    }\n}\n\n/**\n * The main entry point for access to Binance.\n * Each application requires at least one instance of this class.\n * See {@link apiCommand} for an example on using this class.\n * @access public\n */\nexport class BinanceAccess {\n    /**\n     * Create an instance of BinanceAccess. Generally an instance created\n     * via this constructor will need init() called before use.\n     * @param {number} timeout  The number of ms to use as timeout for REST API\n     *                          calls.\n     */\n    constructor(timeout=3000) {\n        this._ready = false;\n        this.base = 'https://api.binance.com/';\n        this._axiosInst = axios.create({\n            baseURL: this.base,\n            timeout: timeout\n        });\n        this.limits = null;\n        this.accounts = new Map();\n        this.streams = new StreamManager();\n        this._coinPairInfo = new Map();\n        this._coinPairs = new Map();\n    }\n\n    /**\n     * Execute a Binance REST API command.\n     * Documentation for the Binance REST API is at\n     * https://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md\n     * @param {object} cmd      A command definition from\n     *                          @link{BinanceCommands}.\n     * @param {object} params   An object containing parameters passed to the\n     *                          API call, stored as key,value pairs.\n     * @param {string} accountName  The name of the Binance account to use for\n     *                          authentication. The account must have been\n     *                          created with {@link loadAccount}.\n     *\n     * @returns The object returned by the Binance API call (see Binance docs)\n     * @throws {Error}  In the following situations (see error string):\n     *                  - BinanceAccess not initialised,\n     *                  - Required parameters missing,\n     *                  - Authentication required but no account given,\n     *                  - Error returned by Binance\n     *                  - Network error\n     *.\n     * @example\n     *   const binance = new BinanceAccess();\n     *   await binance.init();\n     *   binance.loadAccount('Zaphod', MyKey, MySecret);\n     *   const info = await binance.apiCommand(\n     *       BinanceCommands.accountInfo,\n     *       {timestamp: this.binance.getTimestamp()},\n     *       'Zaphod'\n     *   );\n     */\n    async apiCommand(cmd, params={}, accountName=null) {\n        if (!this._ready) throw 'BinanceAccess not ready.';\n        if (cmd === undefined) return false;\n\n        if (this.limits && !this.limits.testAndExecute(cmd.limitType)) {\n            return false;\n        }\n\n        if (cmd.hasOwnProperty('reqParams')) {\n            let paramsOk = true;\n            let missing = [];\n            for (const param of cmd.reqParams) {\n                if (!params.hasOwnProperty(param)) {\n                    paramsOk = false;\n                    missing.push(param);\n                }\n            }\n            if (!paramsOk) {\n                throw `${cmd.name} missing parameters: ${missing.join()}`;\n            }\n        }\n\n        const requestConfig = {params: params};\n\n        if (cmd.reqAuth) {\n            if (accountName === null) throw `Account required for ${cmd.name}`;\n            if (!this.accounts.has(accountName)) {\n                throw new Error(`Account ${accountName} not found.`);\n            }\n            const account = this.accounts.get(accountName);\n            requestConfig.headers = {'X-MBX-APIKEY': account.key};\n            const totalParams = querystring.stringify(params);\n            const hmac = crypto.createHmac('sha256', account.secret);\n            requestConfig.params.signature = hmac.update(totalParams).digest('hex');\n        }\n\n        return this._axiosInst.get(cmd.url, requestConfig)\n            .then(response => {\n                log.debug(\n                    `${cmd.url} returned ${response.statusText} `+\n                    `(${response.status})`\n                );\n                return response.data;\n            })\n            .catch(err => {\n                log.error(`${cmd.url} returned error.`);\n                log.debug('requestConfig:', requestConfig);\n                if (err.response) {\n                    log.error('response:', err.response.data);\n                    log.debug(err.response.status);\n                    //console.log(err.response.headers);\n                } else if (err.request) {\n                    // The request was made but no response received.\n                    log.error('No response');\n                    log.debug(err.request);\n                } else {\n                    log.error('Error', err.message);\n                }\n                throw err;\n            });\n    }\n\n    /**\n     * Initialises the instance with the required historic data.\n     * No other function can be run until init() is completed.\n     */\n    async init() {\n        this._ready = true;\n        const info = await this.apiCommand(BinanceCommands.info);\n        log.info('Local/Server time difference = '\n            +`${Date.now() - info.serverTime}ms`);\n\n        // Init the API request limits\n        this.limits = new Limits();\n        for (const limit of info.rateLimits) {\n            this.limits.setLimit(\n                limit.rateLimitType, parseInt(limit.limit), limit.interval\n            );\n        }\n\n        if (info.exchangeFilters.length > 0) throw 'Exchange filters now present.';\n\n        for (const pair of info.symbols) {\n            this._coinPairInfo.set(pair.symbol, pair);\n        }\n\n        return true;\n    }\n\n    /**\n     * Get the current time according to this instance.\n     * @returns {number} The time in ms relative to some epoch.\n     */\n    getTimestamp() {\n        return Date.now();\n    }\n\n    /**\n     * Load a binance account that may then be used for commands requiring\n     * authentication.\n     * @param {string} name     The account name used to refer to the account\n     *                          in future API calls.\n     * @param {string} key      The Binance key for the account. Usually a\n     *                          64 char string.\n     * @param {string} secret   The Binance secret for the key. Usually a\n     *                          64 char string.\n     */\n    async loadAccount(name, key, secret) {\n        if (!this._ready) throw 'BinanceAccess not ready.';\n        if (this.accounts.has(name)) throw 'Account already exists.';\n        const account = new Account(this, name, key, secret);\n        this.accounts.set(name, account);\n        await account.syncBalances();\n    }\n\n    /**\n     * Get a CoinPair object for the given two coins. Using this method\n     * is preferable to directly creating a CoinPair as it is safer and\n     * avoids duplication.\n     * @param {string} base     The code representing the base coin.\n     * @param {string} quote    The code representing the coin which\n     *                          base is traded against.\n     * @return {CoinPair}       An instance of a CoinPair object.\n     * @throws {Error}          If the coin pair is not available on the\n     *                          exchange.\n     */\n    getCoinPair(base, quote) {\n        const symbol = `${base}${quote}`;\n        if (!this._coinPairs.has(base)) this._coinPairs.set(base, new Map());\n        const baseMap = this._coinPairs.get(base);\n        if (!baseMap.has(quote)) {\n            if (!this._coinPairInfo.has(symbol)) {\n                throw new Error(`${symbol} not available on exchange`);\n            }\n            const coinPair = new CoinPair(\n                base, quote, this._coinPairInfo.get(symbol)\n            );\n            baseMap.set(quote, coinPair);\n            return coinPair;\n        }\n        return baseMap.get(quote);\n    }\n}\n",
    "static": true,
    "longname": "/home/nikos/Documents/code/cryptotrader9000/src/binance.mjs",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 10,
    "kind": "variable",
    "name": "BinanceCommands",
    "memberof": "src/binance.mjs",
    "static": true,
    "longname": "src/binance.mjs~BinanceCommands",
    "access": "public",
    "export": true,
    "importPath": "cryptotrader9000/src/binance.mjs",
    "importStyle": "{BinanceCommands}",
    "description": "Command descriptions that are passed to {@link BinanceAccess.apiCommand}.",
    "lineNumber": 15,
    "type": {
      "types": [
        "{\"time\": *, \"info\": *, \"klines\": *, \"openOrdersForSymbol\": *, \"accountInfo\": *, \"available\": *}"
      ]
    }
  },
  {
    "__docId__": 11,
    "kind": "class",
    "name": "Limits",
    "memberof": "src/binance.mjs",
    "static": true,
    "longname": "src/binance.mjs~Limits",
    "access": "package",
    "export": false,
    "importPath": "cryptotrader9000/src/binance.mjs",
    "importStyle": null,
    "description": "",
    "lineNumber": 61,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 12,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/binance.mjs~Limits",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/binance.mjs~Limits#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 62,
    "undocument": true
  },
  {
    "__docId__": 13,
    "kind": "member",
    "name": "_limits",
    "memberof": "src/binance.mjs~Limits",
    "static": false,
    "longname": "src/binance.mjs~Limits#_limits",
    "access": "private",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 14,
    "kind": "method",
    "name": "setLimit",
    "memberof": "src/binance.mjs~Limits",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/binance.mjs~Limits#setLimit",
    "access": "public",
    "description": null,
    "lineNumber": 66,
    "undocument": true,
    "params": [
      {
        "name": "type",
        "types": [
          "*"
        ]
      },
      {
        "name": "max",
        "types": [
          "*"
        ]
      },
      {
        "name": "interval",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 15,
    "kind": "method",
    "name": "testAndExecute",
    "memberof": "src/binance.mjs~Limits",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/binance.mjs~Limits#testAndExecute",
    "access": "public",
    "description": null,
    "lineNumber": 93,
    "undocument": true,
    "params": [
      {
        "name": "type",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 16,
    "kind": "method",
    "name": "update",
    "memberof": "src/binance.mjs~Limits",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/binance.mjs~Limits#update",
    "access": "public",
    "description": null,
    "lineNumber": 108,
    "undocument": true,
    "params": [
      {
        "name": "time",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 17,
    "kind": "class",
    "name": "BinanceAccess",
    "memberof": "src/binance.mjs",
    "static": true,
    "longname": "src/binance.mjs~BinanceAccess",
    "access": "public",
    "export": true,
    "importPath": "cryptotrader9000/src/binance.mjs",
    "importStyle": "{BinanceAccess}",
    "description": "The main entry point for access to Binance.\nEach application requires at least one instance of this class.\nSee {@link apiCommand} for an example on using this class.",
    "lineNumber": 126,
    "interface": false
  },
  {
    "__docId__": 18,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/binance.mjs~BinanceAccess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/binance.mjs~BinanceAccess#constructor",
    "access": "public",
    "description": "Create an instance of BinanceAccess. Generally an instance created\nvia this constructor will need init() called before use.",
    "lineNumber": 133,
    "params": [
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "timeout",
        "description": "The number of ms to use as timeout for REST API\n                         calls."
      }
    ]
  },
  {
    "__docId__": 19,
    "kind": "member",
    "name": "_ready",
    "memberof": "src/binance.mjs~BinanceAccess",
    "static": false,
    "longname": "src/binance.mjs~BinanceAccess#_ready",
    "access": "private",
    "description": null,
    "lineNumber": 134,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 20,
    "kind": "member",
    "name": "base",
    "memberof": "src/binance.mjs~BinanceAccess",
    "static": false,
    "longname": "src/binance.mjs~BinanceAccess#base",
    "access": "public",
    "description": null,
    "lineNumber": 135,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 21,
    "kind": "member",
    "name": "_axiosInst",
    "memberof": "src/binance.mjs~BinanceAccess",
    "static": false,
    "longname": "src/binance.mjs~BinanceAccess#_axiosInst",
    "access": "private",
    "description": null,
    "lineNumber": 136,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 22,
    "kind": "member",
    "name": "limits",
    "memberof": "src/binance.mjs~BinanceAccess",
    "static": false,
    "longname": "src/binance.mjs~BinanceAccess#limits",
    "access": "public",
    "description": null,
    "lineNumber": 140,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 23,
    "kind": "member",
    "name": "accounts",
    "memberof": "src/binance.mjs~BinanceAccess",
    "static": false,
    "longname": "src/binance.mjs~BinanceAccess#accounts",
    "access": "public",
    "description": null,
    "lineNumber": 141,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 24,
    "kind": "member",
    "name": "streams",
    "memberof": "src/binance.mjs~BinanceAccess",
    "static": false,
    "longname": "src/binance.mjs~BinanceAccess#streams",
    "access": "public",
    "description": null,
    "lineNumber": 142,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 25,
    "kind": "member",
    "name": "_coinPairInfo",
    "memberof": "src/binance.mjs~BinanceAccess",
    "static": false,
    "longname": "src/binance.mjs~BinanceAccess#_coinPairInfo",
    "access": "private",
    "description": null,
    "lineNumber": 143,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 26,
    "kind": "member",
    "name": "_coinPairs",
    "memberof": "src/binance.mjs~BinanceAccess",
    "static": false,
    "longname": "src/binance.mjs~BinanceAccess#_coinPairs",
    "access": "private",
    "description": null,
    "lineNumber": 144,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 27,
    "kind": "method",
    "name": "apiCommand",
    "memberof": "src/binance.mjs~BinanceAccess",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/binance.mjs~BinanceAccess#apiCommand",
    "access": "public",
    "description": "Execute a Binance REST API command.\nDocumentation for the Binance REST API is at\nhttps://github.com/binance-exchange/binance-official-api-docs/blob/master/rest-api.md",
    "examples": [
      "  const binance = new BinanceAccess();\n  await binance.init();\n  binance.loadAccount('Zaphod', MyKey, MySecret);\n  const info = await binance.apiCommand(\n      BinanceCommands.accountInfo,\n      {timestamp: this.binance.getTimestamp()},\n      'Zaphod'\n  );"
    ],
    "lineNumber": 177,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "The object returned by the Binance API call (see Binance docs)"
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "cmd",
        "description": "A command definition from\n                         @link{BinanceCommands}."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "params",
        "description": "An object containing parameters passed to the\n                         API call, stored as key,value pairs."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "accountName",
        "description": "The name of the Binance account to use for\n                         authentication. The account must have been\n                         created with {@link loadAccount}."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "*"
      ],
      "spread": false,
      "description": "The object returned by the Binance API call (see Binance docs)"
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "In the following situations (see error string):\n                 - BinanceAccess not initialised,\n                 - Required parameters missing,\n                 - Authentication required but no account given,\n                 - Error returned by Binance\n                 - Network error\n."
      }
    ]
  },
  {
    "__docId__": 28,
    "kind": "method",
    "name": "init",
    "memberof": "src/binance.mjs~BinanceAccess",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/binance.mjs~BinanceAccess#init",
    "access": "public",
    "description": "Initialises the instance with the required historic data.\nNo other function can be run until init() is completed.",
    "lineNumber": 243,
    "params": [],
    "return": {
      "types": [
        "boolean"
      ]
    }
  },
  {
    "__docId__": 31,
    "kind": "method",
    "name": "getTimestamp",
    "memberof": "src/binance.mjs~BinanceAccess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/binance.mjs~BinanceAccess#getTimestamp",
    "access": "public",
    "description": "Get the current time according to this instance.",
    "lineNumber": 270,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{number} The time in ms relative to some epoch."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "number"
      ],
      "spread": false,
      "description": "The time in ms relative to some epoch."
    },
    "params": []
  },
  {
    "__docId__": 32,
    "kind": "method",
    "name": "loadAccount",
    "memberof": "src/binance.mjs~BinanceAccess",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/binance.mjs~BinanceAccess#loadAccount",
    "access": "public",
    "description": "Load a binance account that may then be used for commands requiring\nauthentication.",
    "lineNumber": 284,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The account name used to refer to the account\n                         in future API calls."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "key",
        "description": "The Binance key for the account. Usually a\n                         64 char string."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "secret",
        "description": "The Binance secret for the key. Usually a\n                         64 char string."
      }
    ],
    "return": null
  },
  {
    "__docId__": 33,
    "kind": "method",
    "name": "getCoinPair",
    "memberof": "src/binance.mjs~BinanceAccess",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/binance.mjs~BinanceAccess#getCoinPair",
    "access": "public",
    "description": "Get a CoinPair object for the given two coins. Using this method\nis preferable to directly creating a CoinPair as it is safer and\navoids duplication.",
    "lineNumber": 303,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "base",
        "description": "The code representing the base coin."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "quote",
        "description": "The code representing the coin which\n                         base is traded against."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "CoinPair"
      ],
      "spread": false,
      "description": "An instance of a CoinPair object."
    },
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If the coin pair is not available on the\n                         exchange."
      }
    ]
  },
  {
    "__docId__": 34,
    "kind": "file",
    "name": "src/binancestream.mjs",
    "content": "import {BinanceCommands} from './binance.mjs';\nimport {ObservableMixin} from './observable';\nimport {TimeSeriesData} from './timeseries';\nimport {log} from './log';\n\nimport Big from 'big.js';\nimport WebSocket from 'ws';\n\n/**\n * @access Public\n */\nexport const BinanceStreams = {\n    // Binance docs indicate klines stream will update every second\n    // but it appears to only update when a trade occurs.\n    klines: {\n        name: 'klines',\n        streamName: '${symbol}@kline_${interval}',\n        reqParams: ['interval', 'symbol']\n    },\n    // Streams at 1Hz pretty consistently\n    ticker: {\n        name: 'ticker',\n        streamName: '${symbol}@ticker',\n        reqParams: ['symbol']\n    },\n    depth: {\n        name: 'depth',\n        streamName: '${symbol}@depth',\n        reqParams: ['symbol']\n    }\n};\n\n/**\n * Maintains WebSocket connections to the Binance stream API.\n * @access Public\n */\nexport class StreamManager extends ObservableMixin(Object) {\n    constructor() {\n        super();\n        this.base = 'wss://stream.binance.com:9443';\n        this.streams = new Map();\n        this.ws = null;\n        this.messageListener = null;\n    }\n\n    /**\n     * Open a stream.\n     * config is an object from BinanceStreams.\n     * messageListener is called each time data is received.\n     */\n    async openStream(config, params={}, messageListener) {\n        // FIXME: WSS connections will be disconnected after 24 hours. Need\n        //        to handle reconnection.\n        let paramsOk = true;\n        let missing = [];\n        for (const param of config.reqParams) {\n            if (!params.hasOwnProperty(param)) {\n                paramsOk = false;\n                missing.push(param);\n            }\n        }\n        if (!paramsOk) {\n            throw `${config.name} missing parameters: ${missing.join()}`;\n        }\n\n        // Binance api wants lower case coinpairs in URIs\n        params.symbol = params.symbol.toLowerCase();\n\n        // Replaces sections of streamName denoted with ${} with\n        // the value of the config parameter named within the curly\n        // braces.\n        const name = config.streamName.replace(/\\${([a-z]+)}/g,\n            (match) => params[match.slice(2,-1)]\n        );\n\n        let streamDefn = null;\n        if (this.streams.has(name)) {\n            streamDefn = this.streams.get(name);\n        } else {\n            streamDefn = {listeners: []};\n            this.streams.set(name, streamDefn);\n            await this._createCombinedStream();\n        }\n        streamDefn.listeners.push(messageListener);\n    }\n\n    _closeCombinedStream() {\n        if (this.messageListener) {\n            this.ws.removeEventListener(this.messageListener);\n            this.messageListener = null;\n        }\n        this.ws.close();\n    }\n\n    async _createCombinedStream() {\n        const addr =\n            `${this.base}/stream?streams=${[...this.streams.keys()].join('/')}`;\n\n        log.debug(`Opening WebSocket ${addr}`);\n\n        if (this.ws) {\n            log.debug('  Closing existing connection.');\n            this._closeCombinedStream();\n        }\n\n        return new Promise((resolve, reject) => {\n            const ws = new WebSocket(addr);\n            ws.onopen = () => {\n                log.debug('Stream created and ready.');\n                this.messageListener =\n                    ws.addEventListener('message', (message) => {\n                        const full = JSON.parse(message.data);\n                        const data = full.data;\n                        const stream = this.streams.get(full.stream);\n                        for (const listener of stream.listeners) {\n                            listener(data);\n                        }\n                    });\n                ws.on('close', (code, reason) => {\n                    log.debug(`WebSocket closed. ${reason} (${code}).`);\n                });\n                this.ws = ws;\n                resolve(ws);\n            };\n            ws.onerror = (err) => reject(err);\n        });\n    }\n}\n\n/**\n * @access private\n */\nconst klinesStreamToRestMap = new Map([['k.t', 0], ['k.o', 1], ['k.h', 2], ['k.l', 3], ['k.c', 4], ['k.v', 5], ['k.T', 6], ['k.q', 7], ['k.n', 8], ['k.V', 9], ['k.Q', 10]]);\n\n/**\n * @access public\n */\nclass BinanceStream extends ObservableMixin(Object) {\n    constructor(binance, type, symbol, attr) {\n        super();\n        this.binance = binance;\n        this.type = type;\n        this.symbol = symbol;\n        this.attr = attr;\n        this.stream = null;\n        // The required attribute is specified using dot notation.\n        // E.g. 'kline.close'.\n        // This code to extract that attribute from the dictionary is a bit\n        // tricky, but basically each element of the array\n        // is a key, on each iteration of reduce we return\n        // the object referenced by that key.\n        this._getAttrData = (data) => attr.split('.').reduce((a,v) => a[v], data);\n    }\n\n    static async create(binance, type, symbol, attr) {\n        const stream = new BinanceStream(binance, type, symbol, attr);\n        stream.stream = await binance.streams.openStream(\n            type,\n            {symbol: symbol},\n            (data) => {\n                stream.notifyObservers(\n                    'newData',\n                    data.E,\n                    Big(stream._getAttrData(data))\n                );\n            }\n        );\n        return stream;\n    }\n}\n\n/**\n * @access public\n */\nexport class BinanceStreamKlines extends BinanceStream {\n    constructor(binance, type, symbol, interval, attr) {\n        super(binance, type, symbol, attr);\n        this.interval = interval;\n    }\n\n    static async create(binance, symbol, interval, attr) {\n        const stream = new BinanceStreamKlines(\n            binance, BinanceStreams.klines, symbol, interval, attr\n        );\n        stream.stream = await binance.streams.openStream(\n            stream.type,\n            {symbol: symbol, interval: interval},\n            (data) => {\n                stream.notifyObservers(\n                    'newData',\n                    data.k.t,\n                    Big(stream._getAttrData(data))\n                );\n            }\n        );\n        return stream;\n    }\n\n    async getHistory(length) {\n        const history = new TimeSeriesData(this.interval);\n        const klines = await this.binance.apiCommand(\n            BinanceCommands.klines,\n            {\n                symbol:   this.symbol,\n                interval: this.interval,\n                limit:    length\n            }\n        );\n        let lastTime = 0;\n        for (const kline of klines) {\n            if (kline[0] < lastTime) throw 'Klines not oldest to newest.';\n            lastTime = kline[0];\n            const attrIndex = klinesStreamToRestMap.get(this.attr);\n            const data = Big(kline[attrIndex]);\n            history.addData(lastTime, data);\n        }\n\n        return history;\n    }\n}\n\n/**\n * @access public\n */\nexport class BinanceStreamTicker extends BinanceStream {\n    // eslint-disable-next-line no-unused-vars\n    getHistory(length) {\n        const history = new TimeSeriesData(this.interval);\n        // FIXME: TODO\n        throw 'Not implemented';\n        // eslint-disable-next-line no-unreachable\n        return history;\n    }\n}\n\n/**\n * @access private\n */\n// eslint-disable-next-line no-unused-vars\nconst tickerStreamToRestMap = new Map();\n\n/**\n * @access public\n */\nexport class BinanceStreamDepth extends BinanceStream {\n    // eslint-disable-next-line no-unused-vars\n    getHistory(length) {\n        const history = new TimeSeriesData(this.interval);\n        // FIXME: TODO\n        throw 'Not implemented';\n        // eslint-disable-next-line no-unreachable\n        return history;\n    }\n}\n\n/**\n * @access private\n */\n// eslint-disable-next-line no-unused-vars\nconst depthStreamToRestMap = new Map();\n\n\n",
    "static": true,
    "longname": "/home/nikos/Documents/code/cryptotrader9000/src/binancestream.mjs",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 35,
    "kind": "variable",
    "name": "BinanceStreams",
    "memberof": "src/binancestream.mjs",
    "static": true,
    "longname": "src/binancestream.mjs~BinanceStreams",
    "access": "Public",
    "export": true,
    "importPath": "cryptotrader9000/src/binancestream.mjs",
    "importStyle": "{BinanceStreams}",
    "description": "",
    "lineNumber": 12,
    "ignore": true,
    "type": {
      "types": [
        "{\"klines\": *, \"ticker\": *, \"depth\": *}"
      ]
    }
  },
  {
    "__docId__": 36,
    "kind": "class",
    "name": "StreamManager",
    "memberof": "src/binancestream.mjs",
    "static": true,
    "longname": "src/binancestream.mjs~StreamManager",
    "access": "Public",
    "export": true,
    "importPath": "cryptotrader9000/src/binancestream.mjs",
    "importStyle": "{StreamManager}",
    "description": "Maintains WebSocket connections to the Binance stream API.",
    "lineNumber": 37,
    "interface": false,
    "expressionExtends": "ObservableMixin(Object)",
    "extends": [
      "Object"
    ],
    "ignore": true
  },
  {
    "__docId__": 37,
    "kind": "variable",
    "name": "klinesStreamToRestMap",
    "memberof": "src/binancestream.mjs",
    "static": true,
    "longname": "src/binancestream.mjs~klinesStreamToRestMap",
    "access": "private",
    "export": false,
    "importPath": "cryptotrader9000/src/binancestream.mjs",
    "importStyle": null,
    "description": "",
    "lineNumber": 133,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 38,
    "kind": "class",
    "name": "BinanceStream",
    "memberof": "src/binancestream.mjs",
    "static": true,
    "longname": "src/binancestream.mjs~BinanceStream",
    "access": "public",
    "export": false,
    "importPath": "cryptotrader9000/src/binancestream.mjs",
    "importStyle": null,
    "description": "",
    "lineNumber": 138,
    "interface": false,
    "expressionExtends": "ObservableMixin(Object)",
    "extends": [
      "Object"
    ],
    "ignore": true
  },
  {
    "__docId__": 39,
    "kind": "class",
    "name": "BinanceStreamKlines",
    "memberof": "src/binancestream.mjs",
    "static": true,
    "longname": "src/binancestream.mjs~BinanceStreamKlines",
    "access": "public",
    "export": true,
    "importPath": "cryptotrader9000/src/binancestream.mjs",
    "importStyle": "{BinanceStreamKlines}",
    "description": "",
    "lineNumber": 175,
    "interface": false,
    "extends": [
      "BinanceStream"
    ]
  },
  {
    "__docId__": 40,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/binancestream.mjs~BinanceStreamKlines",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/binancestream.mjs~BinanceStreamKlines#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 176,
    "undocument": true
  },
  {
    "__docId__": 41,
    "kind": "member",
    "name": "interval",
    "memberof": "src/binancestream.mjs~BinanceStreamKlines",
    "static": false,
    "longname": "src/binancestream.mjs~BinanceStreamKlines#interval",
    "access": "public",
    "description": null,
    "lineNumber": 178,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 42,
    "kind": "method",
    "name": "create",
    "memberof": "src/binancestream.mjs~BinanceStreamKlines",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/binancestream.mjs~BinanceStreamKlines.create",
    "access": "public",
    "description": null,
    "lineNumber": 181,
    "undocument": true,
    "params": [
      {
        "name": "binance",
        "types": [
          "*"
        ]
      },
      {
        "name": "symbol",
        "types": [
          "*"
        ]
      },
      {
        "name": "interval",
        "types": [
          "*"
        ]
      },
      {
        "name": "attr",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 43,
    "kind": "method",
    "name": "getHistory",
    "memberof": "src/binancestream.mjs~BinanceStreamKlines",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/binancestream.mjs~BinanceStreamKlines#getHistory",
    "access": "public",
    "description": null,
    "lineNumber": 199,
    "undocument": true,
    "params": [
      {
        "name": "length",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 44,
    "kind": "class",
    "name": "BinanceStreamTicker",
    "memberof": "src/binancestream.mjs",
    "static": true,
    "longname": "src/binancestream.mjs~BinanceStreamTicker",
    "access": "public",
    "export": true,
    "importPath": "cryptotrader9000/src/binancestream.mjs",
    "importStyle": "{BinanceStreamTicker}",
    "description": "",
    "lineNumber": 225,
    "interface": false,
    "extends": [
      "BinanceStream"
    ]
  },
  {
    "__docId__": 45,
    "kind": "method",
    "name": "getHistory",
    "memberof": "src/binancestream.mjs~BinanceStreamTicker",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/binancestream.mjs~BinanceStreamTicker#getHistory",
    "access": "public",
    "description": null,
    "lineNumber": 227,
    "undocument": true,
    "params": [
      {
        "name": "length",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 46,
    "kind": "variable",
    "name": "tickerStreamToRestMap",
    "memberof": "src/binancestream.mjs",
    "static": true,
    "longname": "src/binancestream.mjs~tickerStreamToRestMap",
    "access": "private",
    "export": false,
    "importPath": "cryptotrader9000/src/binancestream.mjs",
    "importStyle": null,
    "description": "",
    "lineNumber": 240,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 47,
    "kind": "class",
    "name": "BinanceStreamDepth",
    "memberof": "src/binancestream.mjs",
    "static": true,
    "longname": "src/binancestream.mjs~BinanceStreamDepth",
    "access": "public",
    "export": true,
    "importPath": "cryptotrader9000/src/binancestream.mjs",
    "importStyle": "{BinanceStreamDepth}",
    "description": "",
    "lineNumber": 245,
    "interface": false,
    "extends": [
      "BinanceStream"
    ]
  },
  {
    "__docId__": 48,
    "kind": "method",
    "name": "getHistory",
    "memberof": "src/binancestream.mjs~BinanceStreamDepth",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/binancestream.mjs~BinanceStreamDepth#getHistory",
    "access": "public",
    "description": null,
    "lineNumber": 247,
    "undocument": true,
    "params": [
      {
        "name": "length",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 49,
    "kind": "variable",
    "name": "depthStreamToRestMap",
    "memberof": "src/binancestream.mjs",
    "static": true,
    "longname": "src/binancestream.mjs~depthStreamToRestMap",
    "access": "private",
    "export": false,
    "importPath": "cryptotrader9000/src/binancestream.mjs",
    "importStyle": null,
    "description": "",
    "lineNumber": 260,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 50,
    "kind": "file",
    "name": "src/coin.mjs",
    "content": "import {log} from './log';\n\n/**\n * A representation of a coin and value held in that coin.\n * @access public\n */\nexport class Coin {\n    /**\n     * @param {string} name         The name of the coin.\n     * @param {number} initialFree  The initial amount of free, or available\n     *                              value of the coin.\n     * @param {number} initialLocked The initial amount of locked, or\n     *                              un-available value of the coin.\n     */\n    constructor(name, initialFree=0, initialLocked=0) {\n        this.name = name;\n        /**\n         * A quantity of this coin that is available for trading.\n         */\n        this.free = initialFree;\n        /**\n         * A quantity of this coin that is un-available for trading,\n         * usually because it is locked up in existing trades that are\n         * on the order book.\n         */\n        this.locked = initialLocked;\n    }\n}\n\n/**\n * A pair of coins that are traded against one another.\n * E.g. BTCETH (Bitcoin / Ethereum).\n * @access public\n */\nexport class CoinPair {\n    /**\n     * @param {string} base     The code representing the base coin.\n     * @param {string} quote    The code representing the coin which\n     *                          base is traded against.\n     * @param {object} info     The coin information obtained from Binance\n     *                          via BinanceCommands.exchangeInfo.\n     * @throws {Error}          If trading is disabled on the exchange.\n     */\n    constructor(base, quote, info) {\n        /**\n         * The symbol used to represent the coin pair.\n         */\n        this.symbol = `${base}${quote}`;\n\n        log.debug(info);\n\n        if (info.status != 'TRADING') throw `CoinPair ${this.symbol} not trading.`;\n\n        for (const filter of info.filters) {\n            switch (filter.filterType) {\n                case 'PRICE_FILTER':\n                    this.priceFilter = filter;\n                    break;\n                case 'LOT_SIZE':\n                    this.lotSizeFilter = filter;\n                    break;\n                case 'MIN_NOTIONAL':\n                    this.minNotionalFilter = filter;\n                    break;\n                default: throw `${base}${quote} contains unknown filter.`;\n            }\n        }\n    }\n}\n\n",
    "static": true,
    "longname": "/home/nikos/Documents/code/cryptotrader9000/src/coin.mjs",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 51,
    "kind": "class",
    "name": "Coin",
    "memberof": "src/coin.mjs",
    "static": true,
    "longname": "src/coin.mjs~Coin",
    "access": "public",
    "export": true,
    "importPath": "cryptotrader9000/src/coin.mjs",
    "importStyle": "{Coin}",
    "description": "A representation of a coin and value held in that coin.",
    "lineNumber": 7,
    "interface": false
  },
  {
    "__docId__": 52,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/coin.mjs~Coin",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/coin.mjs~Coin#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 15,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "name",
        "description": "The name of the coin."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "initialFree",
        "description": "The initial amount of free, or available\n                             value of the coin."
      },
      {
        "nullable": null,
        "types": [
          "number"
        ],
        "spread": false,
        "optional": false,
        "name": "initialLocked",
        "description": "The initial amount of locked, or\n                             un-available value of the coin."
      }
    ]
  },
  {
    "__docId__": 53,
    "kind": "member",
    "name": "name",
    "memberof": "src/coin.mjs~Coin",
    "static": false,
    "longname": "src/coin.mjs~Coin#name",
    "access": "public",
    "description": null,
    "lineNumber": 16,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 54,
    "kind": "member",
    "name": "free",
    "memberof": "src/coin.mjs~Coin",
    "static": false,
    "longname": "src/coin.mjs~Coin#free",
    "access": "public",
    "description": "A quantity of this coin that is available for trading.",
    "lineNumber": 20,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 55,
    "kind": "member",
    "name": "locked",
    "memberof": "src/coin.mjs~Coin",
    "static": false,
    "longname": "src/coin.mjs~Coin#locked",
    "access": "public",
    "description": "A quantity of this coin that is un-available for trading,\nusually because it is locked up in existing trades that are\non the order book.",
    "lineNumber": 26,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 56,
    "kind": "class",
    "name": "CoinPair",
    "memberof": "src/coin.mjs",
    "static": true,
    "longname": "src/coin.mjs~CoinPair",
    "access": "public",
    "export": true,
    "importPath": "cryptotrader9000/src/coin.mjs",
    "importStyle": "{CoinPair}",
    "description": "A pair of coins that are traded against one another.\nE.g. BTCETH (Bitcoin / Ethereum).",
    "lineNumber": 35,
    "interface": false
  },
  {
    "__docId__": 57,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/coin.mjs~CoinPair",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/coin.mjs~CoinPair#constructor",
    "access": "public",
    "description": "",
    "lineNumber": 44,
    "params": [
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "base",
        "description": "The code representing the base coin."
      },
      {
        "nullable": null,
        "types": [
          "string"
        ],
        "spread": false,
        "optional": false,
        "name": "quote",
        "description": "The code representing the coin which\n                         base is traded against."
      },
      {
        "nullable": null,
        "types": [
          "object"
        ],
        "spread": false,
        "optional": false,
        "name": "info",
        "description": "The coin information obtained from Binance\n                         via BinanceCommands.exchangeInfo."
      }
    ],
    "throws": [
      {
        "types": [
          "Error"
        ],
        "description": "If trading is disabled on the exchange."
      }
    ]
  },
  {
    "__docId__": 58,
    "kind": "member",
    "name": "symbol",
    "memberof": "src/coin.mjs~CoinPair",
    "static": false,
    "longname": "src/coin.mjs~CoinPair#symbol",
    "access": "public",
    "description": "The symbol used to represent the coin pair.",
    "lineNumber": 48,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 59,
    "kind": "member",
    "name": "priceFilter",
    "memberof": "src/coin.mjs~CoinPair",
    "static": false,
    "longname": "src/coin.mjs~CoinPair#priceFilter",
    "access": "public",
    "description": null,
    "lineNumber": 57,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 60,
    "kind": "member",
    "name": "lotSizeFilter",
    "memberof": "src/coin.mjs~CoinPair",
    "static": false,
    "longname": "src/coin.mjs~CoinPair#lotSizeFilter",
    "access": "public",
    "description": null,
    "lineNumber": 60,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 61,
    "kind": "member",
    "name": "minNotionalFilter",
    "memberof": "src/coin.mjs~CoinPair",
    "static": false,
    "longname": "src/coin.mjs~CoinPair#minNotionalFilter",
    "access": "public",
    "description": null,
    "lineNumber": 63,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 62,
    "kind": "file",
    "name": "src/indicator.mjs",
    "content": "import Big from 'big.js';\nimport {ObservableMixin} from './observable';\nimport {BinanceStreamKlines} from './binancestream.mjs';\nimport {TimeSeriesData} from './timeseries';\nimport {findCross, chartIntervalToMs} from './utils';\nimport {log} from './log';\n\nBig.DP = 8;\n\n// Will update based on ticker.\n// But will also need historical data.\nexport class Indicator extends ObservableMixin(Object) {\n    constructor(binance, coinPair) {\n        super();\n        this.binance = binance;\n        this.coinPair = coinPair;\n    }\n\n    getCurrent() {\n        throw 'Implement in sub-class.';\n    }\n}\n\nexport class EMAIndicator extends Indicator {\n    constructor(binance, coinPair, nPeriods, interval) {\n        super(binance, coinPair);\n        this.nPeriods = nPeriods;\n        this.interval = interval;\n        this.intervalMs = chartIntervalToMs(this.interval);\n\n        this.source = null;\n        this.data = new TimeSeriesData(interval);\n    }\n\n    async init(getHistory=0) {\n        // Set up stream\n        this.stream = await BinanceStreamKlines.create(\n            this.binance,\n            this.coinPair.symbol,\n            this.interval,\n            'k.c'   // close price\n        );\n        // Get the history we will need to compute EMA.\n        // getHistory returns a TimeSeriesData which we will use from now on.\n        this.source = await this.stream.getHistory(Math.max(getHistory+1, 1));\n\n        log.debug(`EMAIndicator(${this.nPeriods}): Calculating history.`);\n        const currentTime = this.binance.getTimestamp();\n        for (\n            let time = currentTime - getHistory * this.intervalMs;\n            time < currentTime;\n            time += this.intervalMs\n        ) {\n            this._calculate(time);\n        }\n\n        // Feed stream data in the TimeSeriesData store\n        this.stream.addObserver('newData', this.source.addData, this.source);\n\n        this.source.addObserver('extended', (data,time) => this._calculate(time));\n        this.source.addObserver('replaceRecent', (data,time) => this._calculate(time));\n    }\n\n    static async createAndInit(binance, coinPair, nPeriods, interval, getHistory=0) {\n        log.info(`Creating EMAIndicator for ${coinPair.symbol} (${nPeriods}) ${interval}`);\n        const ema = new EMAIndicator(binance, coinPair, nPeriods, interval);\n        await ema.init(getHistory);\n        return ema;\n    }\n\n    _calculate(time = this.binance.getTimestamp()) {\n        const current = this.source.getAt(time);\n        if (current === undefined) throw new Error('Data missing.');\n        // Either last EMA if available or last close price\n        let last = this.data.getAt(time - this.intervalMs);\n        if (last === undefined) last = current;\n\n        // Weighting for most recent close price.\n        const multiplier = Big(2).div(this.nPeriods + 1);\n\n        const ema = current.times(multiplier).add(last.times(Big(1).sub(multiplier))).round(8);\n        this.data.addData(time, ema);\n        this.notifyObservers('update', time, ema, current);\n        return ema;\n    }\n}\n\nexport class MultiEMAIndicator extends Indicator {\n    constructor(binance, coinPair, interval, lengths) {\n        super(binance, coinPair);\n        this.lengths = lengths;\n        this.lengths.sort((a,b) => b - a);\n        this.interval = interval;\n        this.emas = [];\n        this.orderedEmas = null;\n        this.data = new TimeSeriesData(interval);\n        this.currentTime = 0;\n        this.nUpdates = 0;\n        this.currentPrice = null;\n        this.slow = Math.max(...lengths);\n        this.fast = Math.min(...lengths);\n    }\n\n    async init() {\n        // When calculating historic values, start at 20 candles prior to the current.\n        const history = 20;\n\n        for (const length of this.lengths) {\n            const ema = await EMAIndicator.createAndInit(\n                this.binance,\n                this.coinPair,\n                length,\n                this.interval,\n                history\n            );\n            this.emas.push(ema);\n        }\n\n        // Calculate recent values so that EMAs stabilise.\n        log.debug('MultiEMA: Calculating historic values');\n        const currentTime = this.binance.getTimestamp();\n        const intervalMs = chartIntervalToMs(this.interval);\n        for (\n            let time = currentTime - history * intervalMs;\n            time < currentTime;\n            time += this.interval\n        ) {\n            this._update(time);\n        }\n\n        for (const ema of this.emas) {\n            // FIXME: Should this just be closed prices?\n            // eslint-disable-next-line no-unused-vars\n            ema.addObserver('update', (time, ema, price) => {\n                if (time > this.currentTime) {\n                    this.currentTime = time;\n                    this.nUpdates = 0;\n                }\n                this.currentPrice = price;\n                this.nUpdates ++;\n                if (this.nUpdates == this.lengths.length) {\n                    log.debug(`MultiEMA: Got all ${this.nUpdates} for ${this.currentTime}`);\n                    this._update(time);\n                }\n            });\n        }\n    }\n\n    _update(time) {\n        const newOrder = [];\n\n        for (const ema of this.emas) newOrder.push(ema);\n\n        // Currently in visual order - when price increasing\n        // index 0 will be fastest EMA, when decreasing index 0 will be slowest.\n        // Highest price is index 0.\n        newOrder.sort((a,b) => {\n            const aPrice = a.data.getAt(time);\n            const bPrice = b.data.getAt(time);\n\n            if (aPrice === undefined || bPrice === undefined) {\n                throw new Error('MultiEMA: Price data missing.');\n            }\n\n            const priceCmp = bPrice.cmp(aPrice);\n            return priceCmp == 0 ? a.nPeriods - b.nPeriods : priceCmp;\n        });\n\n        if (this.orderedEmas === null) {\n            this.orderedEmas = newOrder;\n            return;\n        }\n\n        this.notifyObservers('update');\n\n        for (let i = 0; i < newOrder.length; i++) {\n            log.debug(\n                '  ', newOrder[i].nPeriods, 'was(', this.orderedEmas[i].nPeriods, ')',\n                ':', newOrder[i].data.getAt(time).toString()\n            );\n        }\n\n        const cross = findCross(\n            this.orderedEmas, newOrder, this.fast, this.slow, (a) => a.nPeriods\n        );\n        this.orderedEmas = newOrder;\n\n        const crossDebug = [];\n        for (const crossEma of cross.crossed) {\n            crossDebug.push(crossEma.nPeriods);\n        }\n        log.debug(cross.fastSlowCross, crossDebug);\n\n        if (cross.crossed.length == 0) return;\n\n        if (cross.fastSlowCross) {\n            // FIXME: Should we provide prices of emas?\n            // Current price might be even more useful.\n            this.notifyObservers('fastSlowCross', cross.crossed, time, this.currentPrice);\n            return;\n        }\n\n        this.notifyObservers('cross', cross.crossed, time, this.currentPrice);\n    }\n\n    static async createAndInit(binance, coinPair, interval, lengths) {\n        log.info(`Creating MultiEMAIndicator for ${coinPair.symbol} (${interval}) ${lengths}`);\n        const ind = new MultiEMAIndicator(binance, coinPair, interval, lengths);\n        await ind.init();\n        return ind;\n    }\n}\n",
    "static": true,
    "longname": "/home/nikos/Documents/code/cryptotrader9000/src/indicator.mjs",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 63,
    "kind": "class",
    "name": "Indicator",
    "memberof": "src/indicator.mjs",
    "static": true,
    "longname": "src/indicator.mjs~Indicator",
    "access": "public",
    "export": true,
    "importPath": "cryptotrader9000/src/indicator.mjs",
    "importStyle": "{Indicator}",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "interface": false,
    "expressionExtends": "ObservableMixin(Object)",
    "extends": [
      "Object"
    ]
  },
  {
    "__docId__": 64,
    "kind": "class",
    "name": "EMAIndicator",
    "memberof": "src/indicator.mjs",
    "static": true,
    "longname": "src/indicator.mjs~EMAIndicator",
    "access": "public",
    "export": true,
    "importPath": "cryptotrader9000/src/indicator.mjs",
    "importStyle": "{EMAIndicator}",
    "description": null,
    "lineNumber": 24,
    "undocument": true,
    "interface": false,
    "extends": [
      "Indicator"
    ]
  },
  {
    "__docId__": 65,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/indicator.mjs~EMAIndicator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/indicator.mjs~EMAIndicator#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 25,
    "undocument": true
  },
  {
    "__docId__": 66,
    "kind": "member",
    "name": "nPeriods",
    "memberof": "src/indicator.mjs~EMAIndicator",
    "static": false,
    "longname": "src/indicator.mjs~EMAIndicator#nPeriods",
    "access": "public",
    "description": null,
    "lineNumber": 27,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 67,
    "kind": "member",
    "name": "interval",
    "memberof": "src/indicator.mjs~EMAIndicator",
    "static": false,
    "longname": "src/indicator.mjs~EMAIndicator#interval",
    "access": "public",
    "description": null,
    "lineNumber": 28,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 68,
    "kind": "member",
    "name": "intervalMs",
    "memberof": "src/indicator.mjs~EMAIndicator",
    "static": false,
    "longname": "src/indicator.mjs~EMAIndicator#intervalMs",
    "access": "public",
    "description": null,
    "lineNumber": 29,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 69,
    "kind": "member",
    "name": "source",
    "memberof": "src/indicator.mjs~EMAIndicator",
    "static": false,
    "longname": "src/indicator.mjs~EMAIndicator#source",
    "access": "public",
    "description": null,
    "lineNumber": 31,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 70,
    "kind": "member",
    "name": "data",
    "memberof": "src/indicator.mjs~EMAIndicator",
    "static": false,
    "longname": "src/indicator.mjs~EMAIndicator#data",
    "access": "public",
    "description": null,
    "lineNumber": 32,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 71,
    "kind": "method",
    "name": "init",
    "memberof": "src/indicator.mjs~EMAIndicator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/indicator.mjs~EMAIndicator#init",
    "access": "public",
    "description": null,
    "lineNumber": 35,
    "undocument": true,
    "params": [
      {
        "name": "getHistory",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      }
    ],
    "return": null
  },
  {
    "__docId__": 72,
    "kind": "member",
    "name": "stream",
    "memberof": "src/indicator.mjs~EMAIndicator",
    "static": false,
    "longname": "src/indicator.mjs~EMAIndicator#stream",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 74,
    "kind": "method",
    "name": "createAndInit",
    "memberof": "src/indicator.mjs~EMAIndicator",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/indicator.mjs~EMAIndicator.createAndInit",
    "access": "public",
    "description": null,
    "lineNumber": 64,
    "undocument": true,
    "params": [
      {
        "name": "binance",
        "types": [
          "*"
        ]
      },
      {
        "name": "coinPair",
        "types": [
          "*"
        ]
      },
      {
        "name": "nPeriods",
        "types": [
          "*"
        ]
      },
      {
        "name": "interval",
        "types": [
          "*"
        ]
      },
      {
        "name": "getHistory",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 0,
        "defaultValue": "0"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 75,
    "kind": "method",
    "name": "_calculate",
    "memberof": "src/indicator.mjs~EMAIndicator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/indicator.mjs~EMAIndicator#_calculate",
    "access": "private",
    "description": null,
    "lineNumber": 71,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "time",
        "optional": true,
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 76,
    "kind": "class",
    "name": "MultiEMAIndicator",
    "memberof": "src/indicator.mjs",
    "static": true,
    "longname": "src/indicator.mjs~MultiEMAIndicator",
    "access": "public",
    "export": true,
    "importPath": "cryptotrader9000/src/indicator.mjs",
    "importStyle": "{MultiEMAIndicator}",
    "description": null,
    "lineNumber": 88,
    "undocument": true,
    "interface": false,
    "extends": [
      "Indicator"
    ]
  },
  {
    "__docId__": 77,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/indicator.mjs~MultiEMAIndicator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/indicator.mjs~MultiEMAIndicator#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 89,
    "undocument": true
  },
  {
    "__docId__": 78,
    "kind": "member",
    "name": "lengths",
    "memberof": "src/indicator.mjs~MultiEMAIndicator",
    "static": false,
    "longname": "src/indicator.mjs~MultiEMAIndicator#lengths",
    "access": "public",
    "description": null,
    "lineNumber": 91,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 79,
    "kind": "member",
    "name": "interval",
    "memberof": "src/indicator.mjs~MultiEMAIndicator",
    "static": false,
    "longname": "src/indicator.mjs~MultiEMAIndicator#interval",
    "access": "public",
    "description": null,
    "lineNumber": 93,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 80,
    "kind": "member",
    "name": "emas",
    "memberof": "src/indicator.mjs~MultiEMAIndicator",
    "static": false,
    "longname": "src/indicator.mjs~MultiEMAIndicator#emas",
    "access": "public",
    "description": null,
    "lineNumber": 94,
    "undocument": true,
    "type": {
      "types": [
        "*[]"
      ]
    }
  },
  {
    "__docId__": 81,
    "kind": "member",
    "name": "orderedEmas",
    "memberof": "src/indicator.mjs~MultiEMAIndicator",
    "static": false,
    "longname": "src/indicator.mjs~MultiEMAIndicator#orderedEmas",
    "access": "public",
    "description": null,
    "lineNumber": 95,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 82,
    "kind": "member",
    "name": "data",
    "memberof": "src/indicator.mjs~MultiEMAIndicator",
    "static": false,
    "longname": "src/indicator.mjs~MultiEMAIndicator#data",
    "access": "public",
    "description": null,
    "lineNumber": 96,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 83,
    "kind": "member",
    "name": "currentTime",
    "memberof": "src/indicator.mjs~MultiEMAIndicator",
    "static": false,
    "longname": "src/indicator.mjs~MultiEMAIndicator#currentTime",
    "access": "public",
    "description": null,
    "lineNumber": 97,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 84,
    "kind": "member",
    "name": "nUpdates",
    "memberof": "src/indicator.mjs~MultiEMAIndicator",
    "static": false,
    "longname": "src/indicator.mjs~MultiEMAIndicator#nUpdates",
    "access": "public",
    "description": null,
    "lineNumber": 98,
    "undocument": true,
    "type": {
      "types": [
        "number"
      ]
    }
  },
  {
    "__docId__": 85,
    "kind": "member",
    "name": "currentPrice",
    "memberof": "src/indicator.mjs~MultiEMAIndicator",
    "static": false,
    "longname": "src/indicator.mjs~MultiEMAIndicator#currentPrice",
    "access": "public",
    "description": null,
    "lineNumber": 99,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 86,
    "kind": "member",
    "name": "slow",
    "memberof": "src/indicator.mjs~MultiEMAIndicator",
    "static": false,
    "longname": "src/indicator.mjs~MultiEMAIndicator#slow",
    "access": "public",
    "description": null,
    "lineNumber": 100,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 87,
    "kind": "member",
    "name": "fast",
    "memberof": "src/indicator.mjs~MultiEMAIndicator",
    "static": false,
    "longname": "src/indicator.mjs~MultiEMAIndicator#fast",
    "access": "public",
    "description": null,
    "lineNumber": 101,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 88,
    "kind": "method",
    "name": "init",
    "memberof": "src/indicator.mjs~MultiEMAIndicator",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/indicator.mjs~MultiEMAIndicator#init",
    "access": "public",
    "description": null,
    "lineNumber": 104,
    "undocument": true,
    "params": [],
    "return": null
  },
  {
    "__docId__": 92,
    "kind": "method",
    "name": "_update",
    "memberof": "src/indicator.mjs~MultiEMAIndicator",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/indicator.mjs~MultiEMAIndicator#_update",
    "access": "private",
    "description": null,
    "lineNumber": 149,
    "undocument": true,
    "ignore": true,
    "params": [
      {
        "name": "time",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 95,
    "kind": "method",
    "name": "createAndInit",
    "memberof": "src/indicator.mjs~MultiEMAIndicator",
    "generator": false,
    "async": true,
    "static": true,
    "longname": "src/indicator.mjs~MultiEMAIndicator.createAndInit",
    "access": "public",
    "description": null,
    "lineNumber": 206,
    "undocument": true,
    "params": [
      {
        "name": "binance",
        "types": [
          "*"
        ]
      },
      {
        "name": "coinPair",
        "types": [
          "*"
        ]
      },
      {
        "name": "interval",
        "types": [
          "*"
        ]
      },
      {
        "name": "lengths",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 96,
    "kind": "file",
    "name": "src/log.mjs",
    "content": "import {TelegramBot} from './telegram.mjs';\n\nconst Console = console;\n\n/**\n * Options for differing verbosity of log output.\n * @package\n */\nexport const LogLevelType = {\n    none:   0,\n    error:  1,\n    notify: 2,\n    info:   4,\n    debug:  8\n};\n\n/**\n * @protected\n */\nclass Log {\n    /**\n     * Create a logger.\n     * If TELEGRAM_KEY and TELEGRAM_CHANNEL environment variables are set,\n     * then a Telegram bot will be instantiated for output for some log\n     * verbosity levels.\n     */\n    constructor() {\n        /**\n         * Set to a value from {@link LogLevelType} to set the verbosity of output.\n         */\n        this.level = LogLevelType.debug;\n\n        if (process.env.TELEGRAM_KEY !== undefined\n            &&\n            process.env.TELEGRAM_CHANNEL !== undefined\n        ) {\n            this.telegram = new TelegramBot(\n                process.env.TELEGRAM_KEY,\n                process.env.TELEGRAM_CHANNEL,\n                process.env.NET_REQUEST_TIMEOUT || 3000\n            );\n        }\n    }\n\n    /**\n     * Output information about an error.\n     * Will write to the Telegram bot if configured.\n     * @param {...(string|number|object|bool)} args\n     *                                  Any number of objects to output. The\n     *                                  string represented will be concateanted\n     *                                  with a space character.\n     */\n    error(...args) {\n        if (this.level < LogLevelType.error) return;\n        if (this.telegram) this.telegram.message(args.join(' '));\n        Console.log(...args);\n    }\n\n    /**\n     * Output notification information. Notifications are considered to be\n     * of higher importance than informative output.\n     * Will write to the Telegram bot if configured.\n     * @param {...(string|number|object|bool)} args\n     *                                  Any number of objects to output. The\n     *                                  string represented will be concateanted\n     *                                  with a space character.\n     */\n    notify(...args) {\n        if (this.level < LogLevelType.notify) return;\n        if (this.telegram) this.telegram.message(args.join(' '));\n        Console.log(...args);\n    }\n\n    /**\n     * Output an informative message. Considered to be less important than\n     * notifications.\n     * @param {...(string|number|object|bool)} args\n     *                                  Any number of objects to output. The\n     *                                  string represented will be concateanted\n     *                                  with a space character.\n     */\n    info(...args) {\n        if (this.level < LogLevelType.info) return;\n        Console.log(...args);\n    }\n\n    /**\n     * Output debug information.\n     * @param {...(string|number|object|bool)} args\n     *                                  Any number of objects to output. The\n     *                                  string represented will be concateanted\n     *                                  with a space character.\n     */\n    debug(...args) {\n        if (this.level < LogLevelType.debug) return;\n        Console.log(...args);\n    }\n}\n\n/**\n * An instance of the Log for use within the package.\n * @package\n */\nexport const log = new Log();\n\n\n",
    "static": true,
    "longname": "/home/nikos/Documents/code/cryptotrader9000/src/log.mjs",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 97,
    "kind": "variable",
    "name": "Console",
    "memberof": "src/log.mjs",
    "static": true,
    "longname": "src/log.mjs~Console",
    "access": "public",
    "export": false,
    "importPath": "cryptotrader9000/src/log.mjs",
    "importStyle": null,
    "description": null,
    "lineNumber": 3,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    },
    "ignore": true
  },
  {
    "__docId__": 98,
    "kind": "variable",
    "name": "LogLevelType",
    "memberof": "src/log.mjs",
    "static": true,
    "longname": "src/log.mjs~LogLevelType",
    "access": "package",
    "export": true,
    "importPath": "cryptotrader9000/src/log.mjs",
    "importStyle": "{LogLevelType}",
    "description": "Options for differing verbosity of log output.",
    "lineNumber": 9,
    "ignore": true,
    "type": {
      "types": [
        "{\"none\": *, \"error\": number, \"notify\": number, \"info\": number, \"debug\": number}"
      ]
    }
  },
  {
    "__docId__": 99,
    "kind": "variable",
    "name": "log",
    "memberof": "src/log.mjs",
    "static": true,
    "longname": "src/log.mjs~log",
    "access": "package",
    "export": true,
    "importPath": "cryptotrader9000/src/log.mjs",
    "importStyle": "{log}",
    "description": "An instance of the Log for use within the package.",
    "lineNumber": 104,
    "ignore": true,
    "type": {
      "types": [
        "src/log.mjs~Log"
      ]
    }
  },
  {
    "__docId__": 100,
    "kind": "class",
    "name": "Log",
    "memberof": "src/log.mjs",
    "static": true,
    "longname": "src/log.mjs~Log",
    "access": "protected",
    "export": true,
    "importPath": "cryptotrader9000/src/log.mjs",
    "importStyle": null,
    "description": "",
    "lineNumber": 20,
    "pseudoExport": true,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 101,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/log.mjs~Log",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/log.mjs~Log#constructor",
    "access": "public",
    "description": "Create a logger.\nIf TELEGRAM_KEY and TELEGRAM_CHANNEL environment variables are set,\nthen a Telegram bot will be instantiated for output for some log\nverbosity levels.",
    "lineNumber": 27
  },
  {
    "__docId__": 102,
    "kind": "member",
    "name": "level",
    "memberof": "src/log.mjs~Log",
    "static": false,
    "longname": "src/log.mjs~Log#level",
    "access": "public",
    "description": "Set to a value from {@link LogLevelType} to set the verbosity of output.",
    "lineNumber": 31,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 103,
    "kind": "member",
    "name": "telegram",
    "memberof": "src/log.mjs~Log",
    "static": false,
    "longname": "src/log.mjs~Log#telegram",
    "access": "public",
    "description": null,
    "lineNumber": 37,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 104,
    "kind": "method",
    "name": "error",
    "memberof": "src/log.mjs~Log",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/log.mjs~Log#error",
    "access": "public",
    "description": "Output information about an error.\nWill write to the Telegram bot if configured.",
    "lineNumber": 53,
    "params": [
      {
        "nullable": null,
        "types": [
          "...(string|number|object|bool)"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Any number of objects to output. The\n                                 string represented will be concateanted\n                                 with a space character."
      }
    ],
    "return": null
  },
  {
    "__docId__": 105,
    "kind": "method",
    "name": "notify",
    "memberof": "src/log.mjs~Log",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/log.mjs~Log#notify",
    "access": "public",
    "description": "Output notification information. Notifications are considered to be\nof higher importance than informative output.\nWill write to the Telegram bot if configured.",
    "lineNumber": 68,
    "params": [
      {
        "nullable": null,
        "types": [
          "...(string|number|object|bool)"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Any number of objects to output. The\n                                 string represented will be concateanted\n                                 with a space character."
      }
    ],
    "return": null
  },
  {
    "__docId__": 106,
    "kind": "method",
    "name": "info",
    "memberof": "src/log.mjs~Log",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/log.mjs~Log#info",
    "access": "public",
    "description": "Output an informative message. Considered to be less important than\nnotifications.",
    "lineNumber": 82,
    "params": [
      {
        "nullable": null,
        "types": [
          "...(string|number|object|bool)"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Any number of objects to output. The\n                                 string represented will be concateanted\n                                 with a space character."
      }
    ],
    "return": null
  },
  {
    "__docId__": 107,
    "kind": "method",
    "name": "debug",
    "memberof": "src/log.mjs~Log",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/log.mjs~Log#debug",
    "access": "public",
    "description": "Output debug information.",
    "lineNumber": 94,
    "params": [
      {
        "nullable": null,
        "types": [
          "...(string|number|object|bool)"
        ],
        "spread": true,
        "optional": false,
        "name": "args",
        "description": "Any number of objects to output. The\n                                 string represented will be concateanted\n                                 with a space character."
      }
    ],
    "return": null
  },
  {
    "__docId__": 108,
    "kind": "file",
    "name": "src/main.mjs",
    "content": "import {BinanceAccess} from './binance.mjs';\nimport {MultiEMAIndicator} from './indicator.mjs';\nimport {log, LogLevelType} from './log';\n\nimport Big from 'big.js';\n\n(async function main() {\n    log.info('Initialising exchange access');\n    const binance = new BinanceAccess(process.env.NET_REQUEST_TIMEOUT);\n    await binance.init();\n    log.info('  Binance access initialised.');\n\n    log.level = LogLevelType.info;\n\n    await binance.loadAccount(\n        process.env.BINANCEACCOUNT_NAME,\n        process.env.BINANCEACCOUNT_KEY,\n        process.env.BINANCEACCOUNT_SECRET\n    );\n\n    const nulsbtc = binance.getCoinPair('NULS','BTC');\n    const multiEma = await MultiEMAIndicator.createAndInit(binance, nulsbtc, '5m', [21, 13, 8]);\n\n    log.notify(`Bot online. Tracking ${multiEma.coinPair.symbol} ${multiEma.interval}.`);\n\n    let buyAt = null;\n    let cumulative = new Big(0);\n\n    // Possibly the world's simplest trading strategy.\n    // Buy when The fast and slow EMA cross and sell when they cross again.\n    multiEma.addObserver('fastSlowCross', (crossed, time, price) => {\n        const message = [];\n        const signal =\n            crossed.findIndex((e) => e.nPeriods == multiEma.slow)\n            <\n            crossed.findIndex((e) => e.nPeriods == multiEma.fast)\n                ? 'sell' : 'buy';\n        message.push(\n            multiEma.coinPair.symbol, multiEma.interval,\n            'Fast and slow EMA cross.',\n            `Signal: ${signal}.`,\n            `Price: ${price.toString()}.`\n        );\n        if (signal == 'buy') {\n            buyAt = price;\n        } else if (buyAt != null) {\n            const diff = price.sub(buyAt);\n            cumulative = cumulative.plus(diff);\n            message.push(\n                'Sold. Buy/sell difference: ', diff.toString(),\n                '. Cumulative gain:', cumulative.toString()\n            );\n        }\n        log.notify(...message);\n    });\n    multiEma.addObserver('cross', function() {log.debug('Cross');});\n    multiEma.addObserver('update', function() {log.debug('Got MultiEMA update');});\n})();\n",
    "static": true,
    "longname": "/home/nikos/Documents/code/cryptotrader9000/src/main.mjs",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 109,
    "kind": "file",
    "name": "src/observable.mjs",
    "content": "/**\n * Apply the Observable pattern to a subclass.\n * @package\n * @example\n *    How to use:\n *\n *    class Player extends ObservableMixin(Object) {\n *        constructor(maxHP) {\n *            super();\n *            this.hp = maxHP;\n *        }\n *\n *        dmg(value) {\n *            const oldHP = this.hp;\n *            this.hp -= value;\n *            if (this.hp <= 0) {\n *                this.notifyObserver('death', oldHP, this.hp);\n *                return;\n *            }\n *            this.notifyObserver('damage', oldHP, this.hp);\n *        }\n *    }\n *\n *    class A {\n *        constructor() {\n *            this.players = [new Player(100), new Player(60)];\n *            this.players[0].addObserver('death', this.playerDied, this, 0);\n *            this.players[0].addObserver('damage', this.playerDamaged, this, 0);\n *            this.players[1].addObserver('death', this.playerDied, this, 1);\n *            this.players[1].addObserver('damage', this.playerDamaged, this, 1);\n *        }\n *\n *        playerDied(playerIndex, oldValue, newValue) {\n *            console.log(`player ${playerIndex} took ${oldValue - newValue} damage and died.`);\n *            this.players.splice(playerIndex, 1);\n *        }\n *\n *        playerDamaged(playerIndex, oldValue, newValue) {\n *            console.log(`player ${playerIndex} took ${oldValue - newValue} damage.`);\n *        }\n *    }\n *\n *    const a = new A();\n *\n *    while (a.players.length > 0) {\n *        for (player of a.players) {\n *            player.dmg(10);\n *        }\n *    }\n */\nexport const ObservableMixin = superclass => class extends superclass {\n    constructor() {\n        super(...arguments);\n        this.observers = {};\n\n    }\n\n    addObserver(event, fn, useThis, ctxt) {\n        const boundFn = ctxt === undefined ? fn.bind(useThis) : fn.bind(useThis, ctxt);\n        if (this.observers.hasOwnProperty(event)) {\n            this.observers[event].append(boundFn);\n            return;\n        }\n        this.observers[event] = [boundFn];\n    }\n\n    notifyObservers(event, ...args) {\n        if (!this.observers.hasOwnProperty(event))\n            return;\n\n        for (let observer of this.observers[event]) {\n            observer(...args);\n        }\n    }\n};\n\n/**************************************************************************\n**************************************************************************/\n",
    "static": true,
    "longname": "/home/nikos/Documents/code/cryptotrader9000/src/observable.mjs",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 110,
    "kind": "function",
    "name": "ObservableMixin",
    "memberof": "src/observable.mjs",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/observable.mjs~ObservableMixin",
    "access": "package",
    "export": true,
    "importPath": "cryptotrader9000/src/observable.mjs",
    "importStyle": "{ObservableMixin}",
    "description": "Apply the Observable pattern to a subclass.",
    "examples": [
      "   How to use:\n\n   class Player extends ObservableMixin(Object) {\n       constructor(maxHP) {\n           super();\n           this.hp = maxHP;\n       }\n\n       dmg(value) {\n           const oldHP = this.hp;\n           this.hp -= value;\n           if (this.hp <= 0) {\n               this.notifyObserver('death', oldHP, this.hp);\n               return;\n           }\n           this.notifyObserver('damage', oldHP, this.hp);\n       }\n   }\n\n   class A {\n       constructor() {\n           this.players = [new Player(100), new Player(60)];\n           this.players[0].addObserver('death', this.playerDied, this, 0);\n           this.players[0].addObserver('damage', this.playerDamaged, this, 0);\n           this.players[1].addObserver('death', this.playerDied, this, 1);\n           this.players[1].addObserver('damage', this.playerDamaged, this, 1);\n       }\n\n       playerDied(playerIndex, oldValue, newValue) {\n           console.log(`player ${playerIndex} took ${oldValue - newValue} damage and died.`);\n           this.players.splice(playerIndex, 1);\n       }\n\n       playerDamaged(playerIndex, oldValue, newValue) {\n           console.log(`player ${playerIndex} took ${oldValue - newValue} damage.`);\n       }\n   }\n\n   const a = new A();\n\n   while (a.players.length > 0) {\n       for (player of a.players) {\n           player.dmg(10);\n       }\n   }"
    ],
    "lineNumber": 51,
    "ignore": true,
    "params": [
      {
        "name": "superclass",
        "types": [
          "*"
        ]
      }
    ],
    "return": null
  },
  {
    "__docId__": 111,
    "kind": "file",
    "name": "src/telegram.mjs",
    "content": "import axios from 'axios';\n\nimport {log} from './log';\n\n/**\n * @access package\n */\nexport class TelegramBot {\n    constructor(key, channel, timeout=3000) {\n        this.key = key;\n        this.channel = channel;\n        this.base = 'https://api.telegram.org/bot';\n        this._axiosInst = axios.create({\n            baseURL: this.base,\n            timeout: timeout\n        });\n\n    }\n\n    async message(m) {\n        const url = `${this.base}${this.key}/sendMessage`;\n        const cfg = {\n            params: {\n                chat_id: this.channel,\n                text: m,\n                disable_notification: true\n            }\n        };\n\n        return this._axiosInst.get(url, cfg)\n            .then(response => {\n                log.debug(\n                    `${url} returned ${response.statusText} `+\n                    `(${response.status})`+\n                    `${response.data}`\n                );\n                return response.data;\n            })\n            .catch(err => {\n                log.error(`${url} returned error.`);\n                if (err.response) {\n                    log.error('response:', err.response.data);\n                    log.error(err.response.status);\n                    //console.log(err.response.headers);\n                } else if (err.request) {\n                    // The request was made but no response received.\n                    log.error('No response');\n                    log.error(err.request);\n                } else {\n                    log.error('Error', err.message);\n                }\n                throw err;\n            });\n    }\n}\n",
    "static": true,
    "longname": "/home/nikos/Documents/code/cryptotrader9000/src/telegram.mjs",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 112,
    "kind": "class",
    "name": "TelegramBot",
    "memberof": "src/telegram.mjs",
    "static": true,
    "longname": "src/telegram.mjs~TelegramBot",
    "access": "package",
    "export": true,
    "importPath": "cryptotrader9000/src/telegram.mjs",
    "importStyle": "{TelegramBot}",
    "description": "",
    "lineNumber": 8,
    "interface": false,
    "ignore": true
  },
  {
    "__docId__": 113,
    "kind": "constructor",
    "name": "constructor",
    "memberof": "src/telegram.mjs~TelegramBot",
    "generator": false,
    "async": false,
    "static": false,
    "longname": "src/telegram.mjs~TelegramBot#constructor",
    "access": "public",
    "description": null,
    "lineNumber": 9,
    "undocument": true
  },
  {
    "__docId__": 114,
    "kind": "member",
    "name": "key",
    "memberof": "src/telegram.mjs~TelegramBot",
    "static": false,
    "longname": "src/telegram.mjs~TelegramBot#key",
    "access": "public",
    "description": null,
    "lineNumber": 10,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 115,
    "kind": "member",
    "name": "channel",
    "memberof": "src/telegram.mjs~TelegramBot",
    "static": false,
    "longname": "src/telegram.mjs~TelegramBot#channel",
    "access": "public",
    "description": null,
    "lineNumber": 11,
    "undocument": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 116,
    "kind": "member",
    "name": "base",
    "memberof": "src/telegram.mjs~TelegramBot",
    "static": false,
    "longname": "src/telegram.mjs~TelegramBot#base",
    "access": "public",
    "description": null,
    "lineNumber": 12,
    "undocument": true,
    "type": {
      "types": [
        "string"
      ]
    }
  },
  {
    "__docId__": 117,
    "kind": "member",
    "name": "_axiosInst",
    "memberof": "src/telegram.mjs~TelegramBot",
    "static": false,
    "longname": "src/telegram.mjs~TelegramBot#_axiosInst",
    "access": "private",
    "description": null,
    "lineNumber": 13,
    "undocument": true,
    "ignore": true,
    "type": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 118,
    "kind": "method",
    "name": "message",
    "memberof": "src/telegram.mjs~TelegramBot",
    "generator": false,
    "async": true,
    "static": false,
    "longname": "src/telegram.mjs~TelegramBot#message",
    "access": "public",
    "description": null,
    "lineNumber": 20,
    "undocument": true,
    "params": [
      {
        "name": "m",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 119,
    "kind": "file",
    "name": "src/timeseries.mjs",
    "content": "import {chartIntervalToMs} from './utils';\nimport {ObservableMixin} from './observable';\n\n// Assumes data will be added for all intervals, so we're not optimising for\n// space wrt missing data.\n\n/**\n * Data store for time series data - i.e. data that is associated with\n * fixed intervals of time and has no gaps.\n * @package\n */\nexport class TimeSeriesData extends ObservableMixin(Object) {\n    /**\n     * @param {string} interval     An string representing a time interval.\n     *                              For accepted values, see {@link chartIntervalToMs}.\n     */\n    constructor(interval) {\n        super();\n        /** Time interval in string form. */\n        this.intervalStr = interval;\n        /** Time interval in milliseconds. */\n        this.interval = chartIntervalToMs(interval);\n        this._firstTime = Infinity;\n        this._lastTime = 0;\n        this._data = [];\n    }\n\n    /**\n     * If a time is given that is after the last data sample, then\n     * fill the data up to time.\n     * @param {number} time     Time in milliseconds.\n     */\n    _checkAndFillTrailingData(time) {\n        if (time % this.interval !== 0) time -= (time % this.interval);\n        const gap = time - this._lastTime;\n        if (gap < this.interval) return;\n        const nMissing = Math.ceil(gap / this.interval);\n        //console.log(`WARNING: _checkAndFillTrailingData adding ${nMissing}`);\n        this._data = this._data.concat(\n            new Array(nMissing).fill(this._data[this._data.length - 1])\n        );\n        this._lastTime = time;\n    }\n\n    /**\n     * If a time is given that is prior to the first data sample, then\n     * fill the data from time to the first existing sample.\n     * @param {number} time     Time in milliseconds.\n     */\n    _checkAndFillLeadingData(time, data) {\n        if (time % this.interval !== 0) time -= (time % this.interval);\n        const gap = this._firstTime - time;\n        if (gap < this.interval) return;\n        const nMissing = Math.ceil(gap / this.interval);\n        //console.log(`WARNING: _checkAndFillTrailingData adding ${nMissing}`);\n        this._data = new Array(nMissing).fill(data).concat(this._data);\n        this._firstTime = time;\n    }\n\n    /**\n     * Add data to the series.\n     * If data is provided for a time that has existing data, then that data\n     * is overwritten.\n     * If data is provided more than one interval before or after existing data\n     * then the empty samples are padded with the preceeding data value.\n     * @param {number} time     The time in milliseconds.\n     * @param          data     The data value to store at this time.\n     */\n    addData(time, data) {\n        if (time % this.interval !== 0) time -= (time % this.interval);\n\n        if (this._data.length === 0) {\n            this._data.push(data);\n            this._lastTime = this._firstTime = time;\n        } else if (time > this._lastTime) {\n            // Comes after last sample\n            this._checkAndFillTrailingData(time - this.interval);\n            this._data.push(data);\n            this._lastTime = time;\n            this.notifyObservers('extended', data, time);\n        } else if (time < this._firstTime) {\n            // Comes before first sample\n            this._checkAndFillLeadingData(time + this.interval, data);\n            this._data.unshift(data);\n            this._firstTime = time;\n        } else {\n            // If it falls exactly on the interval, overwrites an existing\n            // sample, otherwise an error.\n            const replaceIndex = (time - this._firstTime) / this.interval;\n            this._data[replaceIndex] = data;\n            this.notifyObservers('replaceRecent', data, time);\n        }\n    }\n\n    /**\n     * Get the most recent samples. By default, this includes the most recent\n     * interval which will likely not be closed.\n     * If the current time is past the last data sample, then the value of the\n     * last data sample will be used to fill the data samples up to the current time.\n     * @param {number}      n           The number of samples to return.\n     *                                  If n > the number of samples available, all\n     *                                  available samples will be returned.\n     * @param {currentTime} currentTime The current time in milliseconds. This\n     *                                  is required to determine if the latest\n     *                                  sample is closed and to pad data\n     *                                  if the current time is after the last\n     *                                  data sample.\n     * @param {boolean}     [includeOpen=true]\n     *                                  Whether to include open or only closed\n     *                                  samples. A sample is closed once the full\n     *                                  time for the interval has elapsed.\n     *\n     * @return {Array<number|string|boolean|object>}\n     *                                  An array containing the requested samples,\n     *                                  or an empty array if there is no data\n     *                                  stored.\n     * @throws {Error}  If n < 1.\n     */\n    getRecent(n, currentTime, includeOpen=true) {\n        if (n < 1) throw new Error('n < 1');\n        if (this._data.length < 1) return [];\n\n        this._checkAndFillTrailingData(currentTime);\n        const lastSampleOpen = currentTime - this._lastTime < this.interval;\n\n        if (includeOpen || !lastSampleOpen) return this._data.slice(-n);\n\n        const offset = this._data.length - 1;\n        return this._data.slice(Math.max(0, offset - n), offset);\n    }\n\n    /**\n     * Get a value from the time series for a specific time.\n     * @param {number} time     The time in the series from where data will\n     *                          be retrieved.\n     * @returns        The data at that time, or undefined if no data exists\n     *                 at that time.\n     */\n    getAt(time) {\n        time -= (time % this.interval);\n\n        if (time < this._firstTime || time > this._lastTime) {\n            return undefined;\n        }\n\n        const index = (time - this._firstTime) / this.interval;\n        return this._data[index];\n    }\n\n    // eslint-disable-next-line no-unused-vars\n    getRange(startTime, endTime) {\n    }\n}\n",
    "static": true,
    "longname": "/home/nikos/Documents/code/cryptotrader9000/src/timeseries.mjs",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 120,
    "kind": "class",
    "name": "TimeSeriesData",
    "memberof": "src/timeseries.mjs",
    "static": true,
    "longname": "src/timeseries.mjs~TimeSeriesData",
    "access": "package",
    "export": true,
    "importPath": "cryptotrader9000/src/timeseries.mjs",
    "importStyle": "{TimeSeriesData}",
    "description": "Data store for time series data - i.e. data that is associated with\nfixed intervals of time and has no gaps.",
    "lineNumber": 12,
    "interface": false,
    "expressionExtends": "ObservableMixin(Object)",
    "extends": [
      "Object"
    ],
    "ignore": true
  },
  {
    "__docId__": 121,
    "kind": "file",
    "name": "src/utils.mjs",
    "content": "/* eslint-disable no-fallthrough */\n\n/**\n * @access package\n */\nexport function intervalToMs(intervalStr, multiplier=1) {\n    switch (intervalStr) {\n        case 'M':\n            throw new Error(\"Months aren't supported because they are too variable. Sorry.\");\n        case 'w':\n            multiplier *= 7;\n        case 'd':\n        case 'DAY':\n            multiplier *= 24;\n        case 'h':\n            multiplier *= 60;\n        case 'm':\n        case 'MINUTE':\n            multiplier *= 60;\n        case 'SECOND': return 1000 * multiplier;\n        default: throw new Error('bad intervalStr');\n    }\n}\n\n/**\n * A chart interval string is a number followed by a time period.\n * Where time period may be any of:\n * m -> minutes; h -> hours; d -> days; w -> weeks; M -> months\n * @access package\n */\nexport function chartIntervalToMs(intervalStr) {\n    const result = intervalStr.match(/^([\\d]+)([mhdwM])$/);\n    if (result === null) {\n        throw new Error(`${intervalStr} is not a valid intervalStr.`);\n    }\n    const num = result[1], period = result[2];\n    const ms = intervalToMs(period, num);\n    return ms;\n}\n\n/**\n * @typedef {any} Any   Any type.\n * @access package\n */\n\n/**\n * @typedef {any} ComparisonType    Any type, but all parameters of this type\n *                                  must be comparable.\n * @access package\n */\n\n/**\n * Given two arrays, with values that can be compared, determine which\n * values 'crossed' from the first to the second.\n * Also determine if the fast and slow (mininum value and maximum value) crossed.\n * For example, for a = [1,2,3,4], and b = [1,3,2,4]. Values 2 and 3 are considered\n * to have crossed as they swapped position.\n * @access package\n *\n * @param {Array<Any>} a      The first array of values.\n * @param {Array<Any>} b      The first array of values.\n * @param {ComparisonType}    fast   The 'fast' value.\n * @param {ComparisonType}    slow   The 'slow' value.\n * @param {function(a:Any): ComparisonType} valueFn   A function for retrieving the\n *                                      comparison value from 'a' and 'b',\n *                                      if they are compound objects and the comparison\n *                                      value is a property.\n *\n * @returns {{fastSlowCross: bool, crossed: Array<Any>}}    An object with\n * properties 'fastSlowCross', which indicates if fast and slow crossed, and\n * the array 'crossed' which contains any elements that crossed, or is empty\n * if no cross occurred.\n *\n * @example\n * const a = [1,2,3,4]\n * const b = [1,4,3,2]\n * const cross = findCross(a, b, 1, 4);\n * console.log(cross); // {fastSlowCross: false, crossed: [4,3,2]\n */\nexport function findCross(a, b, fast, slow, valueFn=(a)=>a) {\n    let firstCross = null;\n    let afterCross = null;\n    // Assume min and max cross unless we see one of them outside of the\n    // cross zone.\n    let fastSlowCross = true;\n\n    // Two separate loops seems to be ever so slightly faster.\n    for (let r = a.length-1; afterCross === null && r > 0; r--) {\n        if (valueFn(a[r]) != valueFn(b[r])) afterCross = r+1;\n        else if (valueFn(a[r]) == fast || valueFn(a[r]) == slow) fastSlowCross = false;\n    }\n\n    if (afterCross === null) return {fastSlowCross:false, crossed:[]};\n\n    for (let l = 0; firstCross === null && l < afterCross; l++) {\n        if (valueFn(a[l]) != valueFn(b[l])) firstCross = l;\n        else if (valueFn(a[l]) == fast || valueFn(a[l]) == slow) fastSlowCross = false;\n    }\n\n    return {fastSlowCross, crossed:b.slice(firstCross, afterCross)};\n}\n\n\n",
    "static": true,
    "longname": "/home/nikos/Documents/code/cryptotrader9000/src/utils.mjs",
    "access": "public",
    "description": null,
    "lineNumber": 1
  },
  {
    "__docId__": 122,
    "kind": "function",
    "name": "intervalToMs",
    "memberof": "src/utils.mjs",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils.mjs~intervalToMs",
    "access": "package",
    "export": true,
    "importPath": "cryptotrader9000/src/utils.mjs",
    "importStyle": "{intervalToMs}",
    "description": "",
    "lineNumber": 6,
    "ignore": true,
    "params": [
      {
        "name": "intervalStr",
        "types": [
          "*"
        ]
      },
      {
        "name": "multiplier",
        "optional": true,
        "types": [
          "number"
        ],
        "defaultRaw": 1,
        "defaultValue": "1"
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 123,
    "kind": "function",
    "name": "chartIntervalToMs",
    "memberof": "src/utils.mjs",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils.mjs~chartIntervalToMs",
    "access": "package",
    "export": true,
    "importPath": "cryptotrader9000/src/utils.mjs",
    "importStyle": "{chartIntervalToMs}",
    "description": "A chart interval string is a number followed by a time period.\nWhere time period may be any of:\nm -> minutes; h -> hours; d -> days; w -> weeks; M -> months",
    "lineNumber": 31,
    "ignore": true,
    "params": [
      {
        "name": "intervalStr",
        "types": [
          "*"
        ]
      }
    ],
    "return": {
      "types": [
        "*"
      ]
    }
  },
  {
    "__docId__": 124,
    "kind": "typedef",
    "name": "Any",
    "memberof": "src/utils.mjs",
    "static": true,
    "longname": "src/utils.mjs~Any",
    "access": "package",
    "description": "",
    "type": {
      "types": [
        "any"
      ],
      "optional": false,
      "name": "Any"
    },
    "ignore": true
  },
  {
    "__docId__": 125,
    "kind": "typedef",
    "name": "ComparisonType",
    "memberof": "src/utils.mjs",
    "static": true,
    "longname": "src/utils.mjs~ComparisonType",
    "access": "package",
    "description": "",
    "type": {
      "types": [
        "any"
      ],
      "optional": false,
      "name": "ComparisonType"
    },
    "ignore": true
  },
  {
    "__docId__": 126,
    "kind": "function",
    "name": "findCross",
    "memberof": "src/utils.mjs",
    "generator": false,
    "async": false,
    "static": true,
    "longname": "src/utils.mjs~findCross",
    "access": "package",
    "export": true,
    "importPath": "cryptotrader9000/src/utils.mjs",
    "importStyle": "{findCross}",
    "description": "Given two arrays, with values that can be compared, determine which\nvalues 'crossed' from the first to the second.\nAlso determine if the fast and slow (mininum value and maximum value) crossed.\nFor example, for a = [1,2,3,4], and b = [1,3,2,4]. Values 2 and 3 are considered\nto have crossed as they swapped position.",
    "examples": [
      "const a = [1,2,3,4]\nconst b = [1,4,3,2]\nconst cross = findCross(a, b, 1, 4);\nconsole.log(cross); // {fastSlowCross: false, crossed: [4,3,2]"
    ],
    "lineNumber": 80,
    "unknown": [
      {
        "tagName": "@returns",
        "tagValue": "{{fastSlowCross: bool, crossed: Array<Any>}}    An object with\nproperties 'fastSlowCross', which indicates if fast and slow crossed, and\nthe array 'crossed' which contains any elements that crossed, or is empty\nif no cross occurred."
      }
    ],
    "params": [
      {
        "nullable": null,
        "types": [
          "Array<Any>"
        ],
        "spread": false,
        "optional": false,
        "name": "a",
        "description": "The first array of values."
      },
      {
        "nullable": null,
        "types": [
          "Array<Any>"
        ],
        "spread": false,
        "optional": false,
        "name": "b",
        "description": "The first array of values."
      },
      {
        "nullable": null,
        "types": [
          "ComparisonType"
        ],
        "spread": false,
        "optional": false,
        "name": "fast",
        "description": "The 'fast' value."
      },
      {
        "nullable": null,
        "types": [
          "ComparisonType"
        ],
        "spread": false,
        "optional": false,
        "name": "slow",
        "description": "The 'slow' value."
      },
      {
        "nullable": null,
        "types": [
          "function(a:Any): ComparisonType"
        ],
        "spread": false,
        "optional": false,
        "name": "valueFn",
        "description": "A function for retrieving the\n                                     comparison value from 'a' and 'b',\n                                     if they are compound objects and the comparison\n                                     value is a property."
      }
    ],
    "return": {
      "nullable": null,
      "types": [
        "{fastSlowCross: bool, crossed: Array<Any>}"
      ],
      "spread": false,
      "description": "An object with\nproperties 'fastSlowCross', which indicates if fast and slow crossed, and\nthe array 'crossed' which contains any elements that crossed, or is empty\nif no cross occurred."
    },
    "ignore": true
  },
  {
    "kind": "index",
    "content": "# cryptotrader9000\nA very basic rule based trading bot for Binance. For fun, not profit.\n\n# Setting up and running the test bot\n\n1. `git clone https://github.com/nikosandronikos/cryptotrader9000.git`\n\n2. Install dependencies with\n```npm install``` or ```npm install --production```\n\n3. Set environment variables (see [Environment Variables](#Environment Variables))\n\n3. Run the test bot with\n```npm start```\n\n**Note** *, if running nodejs directly rather than via the '`npm start`'\ncommand, the '`--experimental-modules`' flag is required to enable ES6\nmodule support in NodeJS.*\n\n### Environment Variables\nThe following environment variables are required. They may be configured in\na '.env' file or within the OS environment:\n- BINANCEACCOUNT_NAME; A human readable name for the account\n- BINANCEACCOUNT_KEY; The account key from Binance\n- BINANCEACCOUNT_SECRET; The account key secret from Binance\n- TELEGRAM_KEY; (optional) A key for a telegram bot\n- TELEGRAM_CHANNEL; (optional) The telegram channel to send messages to\n\n# Using the library\n*There is currently no mechanism to simply import this as a library into your\nown packages. In the future this module will be available via NPM.*\n\nThe initial entry point is the [BinanceAccess](https://nikosandronikos.github.io/cryptotrader9000/class/src/binance.mjs~BinanceAccess.html) class.\n\nFull documentation is available at:\nhttps://nikosandronikos.github.io/cryptotrader9000/\n\nNote that esdoc doesn't like the method used to mixin ObservableMixin to other\nclasses. This results in blank documentation for any class using ObservableMixin.\nSorry! You'll just have to look at the source for now.\n\n# Tests\n[![Build Status](https://travis-ci.org/nikosandronikos/cryptotrader9000.svg?branch=master)](https://travis-ci.org/nikosandronikos/cryptotrader9000)\n\nRun the tests with\n```npm test```\n\n",
    "longname": "/home/nikos/Documents/code/cryptotrader9000/README.md",
    "name": "./README.md",
    "static": true,
    "access": "public"
  }
]